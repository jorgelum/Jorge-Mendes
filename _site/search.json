[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Jorge L. Mendes",
    "section": "",
    "text": "Me chamo Jorge. Sou graduando em Engenharia Química pela Universidade Federal de São Paulo.\nComecei a ter afinidade pela linguagem R no final de 2020 e me apaixonei pelo RMarkdown/Quarto."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jorge Mendes",
    "section": "",
    "text": "Arbitragem da Premier League\n\n\n\n\n\n\n\nanalysis\n\n\nfutebol\n\n\nPL\n\n\nggplot\n\n\n\n\nComo é a arbitragem da Premier League?\n\n\n\n\n\n\nJan 6, 2024\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nEleição 2022\n\n\n\n\n\n\n\ngoverno\n\n\nDados\n\n\ngeobr\n\n\nanalytics\n\n\nggplot\n\n\n\n\nAs eleições de 2022 foram extremamente concorridas, sendo bem disputadas no primeiro e no segundo turno.\n\n\n\n\n\n\nDec 29, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nBase dos Dados\n\n\n\n\n\n\n\nDados\n\n\n\n\nUm breve tutorial de como utilizar o pacote base dos dados.\n\n\n\n\n\n\nDec 17, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nComo utilizar o xgboost no R\n\n\n\n\n\n\n\nxgboost\n\n\nclassificação\n\n\nTree\n\n\n\n\nO xgboost é uma biblioteca poderosa para criar modelos de previsão\n\n\n\n\n\n\nNov 15, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nUtilizando R para Modelagem\n\n\n\n\n\n\n\nODE\n\n\nggplot\n\n\ndeSolve\n\n\n\n\nComo utilizar a biblioteca deSolve para resolver EDO’s\n\n\n\n\n\n\nApr 13, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nOtimização\n\n\n\n\n\n\n\nlpsolve\n\n\n\n\nOtimização utilizando a linguagem R\n\n\n\n\n\n\nMar 2, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nPoder de Compra e Big Mac\n\n\n\n\n\n\n\nEconomics\n\n\nggplot\n\n\ndplyr\n\n\n\n\nO big mac é um dos pratos mais famosos do mcdonalds e virou uma ferramenta de estudos econômicos\n\n\n\n\n\n\nFeb 27, 2023\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nUsando R para acessar google sheet\n\n\n\n\n\nIsso é um pequeno tutorial para acessar o google sheets com a biblioteca googlesheets4 e base de dados utilizada vai ser da copa do mundo.\n\n\n\n\n\n\nNov 5, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nExtraindo dados da wikipedia\n\n\n\n\n\n\n\nweb scraping\n\n\nparlamento\n\n\ngoverno\n\n\nReino Unido\n\n\n\n\nWeb Scraping da página da Wikipédia\n\n\n\n\n\n\nNov 3, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nComo usar API do Twitter\n\n\n\n\n\n\n\napi\n\n\nseleção\n\n\ntwitter\n\n\n\n\nUm tutorial básico de como acessar a API do Twitter para obter dados\n\n\n\n\n\n\nOct 10, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nSaneamento no Estado de São Paulo\n\n\n\n\n\n\n\nanalysis\n\n\nnew\n\n\ncode\n\n\nsaneamento\n\n\ncsv\n\n\ngeobr\n\n\nggplot\n\n\n\n\nAtlas do Esgoto\n\n\n\n\n\n\nSep 10, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nCampeonato Brasileiro\n\n\n\n\n\n\n\nanalysis\n\n\nnew\n\n\ncode\n\n\nfutebol\n\n\n\n\nAnalisando os resultados do campeonato brasileiro\n\n\n\n\n\n\nJul 14, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\n  \n\n\n\n\nPetróleo\n\n\n\n\n\n\n\nanalysis\n\n\nnew\n\n\ncode\n\n\nANP\n\n\n\n\nPanorama a respeito do petróleo e biblioteca ggplot\n\n\n\n\n\n\nJul 4, 2022\n\n\nJorge Luiz Mendes\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Petroleum/Petroleum.html",
    "href": "posts/Petroleum/Petroleum.html",
    "title": "Petróleo",
    "section": "",
    "text": "Atualizado1 : 23/03/2023"
  },
  {
    "objectID": "posts/Petroleum/Petroleum.html#bibliotecas",
    "href": "posts/Petroleum/Petroleum.html#bibliotecas",
    "title": "Petróleo",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(tidyverse)\nlibrary(gghighlight)\nlibrary(magrittr)\nlibrary(plyr)\nlibrary(knitr)\nlibrary(geobr)\nlibrary(glue)\n\n\n\n\n\n\n\nE para que servem essas bibliotecas?\n\n\n\nO Tidyverse é um conjunto de bibliotecas muito útil que pode ser carregada rapidamente.\n\n\n\n\n\nreadr: Importar/Carregar dados;\ndplyr(tidyr, tibble, plyr): Manipulação e transformação de dados;\nggplot: Visualização de dados;\nmagrittr: Operador Pipe(“O velho %>%”) facilita a escrita do código. Também existe o novo pipe (“|>”) nativo nas versões atuais do RStudio;\nknitr: Ajuda a formatar tabelas."
  },
  {
    "objectID": "posts/Petroleum/Petroleum.html#visão-geral",
    "href": "posts/Petroleum/Petroleum.html#visão-geral",
    "title": "Petróleo",
    "section": "Visão Geral",
    "text": "Visão Geral\nQuais países possuem as maiores reservas de petróleo?\nCarregando os dados.\n\nReserva_internacional <- readr::read_csv2(\"https://www.gov.br/anp/pt-br/centrais-de-conteudo/publicacoes/anuario-estatistico/arquivos-anuario-estatistico-2021-metadados-pdf-e-dados-abertos-csv/secao-1-panorama-internacional/dados-abertos-csv/anuario-2021-dados_abertos-tabela1-1.csv\")\n\nPlotando o Gráfico.\n\nReserva_internacional %>% filter(ANO ==2020) %>% \n  arrange(desc(`VALOR DA RESERVA`)) %>% slice(1:10) %>% \n    ggplot() +\n    geom_col(aes(x =`VALOR DA RESERVA`,y =reorder(PAÍS,`VALOR DA RESERVA`),\n            fill = BLOCO) ) +\n          scale_fill_manual(values = c(\"#de6d04\",\"#0f7a38\")) +\n          labs(x =\"Bilhões de Barris\", y = \"\",\n               title =\"As 10 Maiores Reservas de Petróleo\",\n               subtitle =\"em 2020\" ,\n               caption = \"Mendes,Jorge L.\") +\n  \n         \n    theme(plot.title = element_text(face = \"bold\"))\n\n\n\n\nA OPEP (Organização dos Países Exportadores de Petróleo) é uma organização que tem por objetivo regular a produção do petróleo para dar estabilidade no mercado internacionall.\nQuem são maiores produtores?\nCarregando os dados.\n\nProducao_internacional <- readr::read_csv2(\"https://www.gov.br/anp/pt-br/centrais-de-conteudo/publicacoes/anuario-estatistico/arquivos-anuario-estatistico-2021-metadados-pdf-e-dados-abertos-csv/secao-1-panorama-internacional/dados-abertos-csv/anuario-2021-dados_abertos-tabela1-2.csv\")\n\nProducao_internacional$PRODUÇÃO <- round(Producao_internacional$PRODUÇÃO,2)\n\nPlotando o Gráfico adicionando labels.\n\n Producao_internacional %>% filter(ANO == 2020) %>% \n  arrange(desc(PRODUÇÃO)) %>% \n   slice(1:10) %>% \n   mutate(label = glue::glue(\"{round(PRODUÇÃO/1000,2)}k\")) %>%  \n  ggplot() +\n   aes(x =PRODUÇÃO ,y =reorder(PAÍS,PRODUÇÃO),\n                fill=BLOCO, label =label) +\n   geom_col() +\n        scale_fill_manual(values = c(\"#de6d04\",\"#0f7a38\")) +\n         labs(x =\"Milhares de Barris por Dia\", y = \"\",\n              title = \"Os 10 Maiores Produtores de Petróleo\",\n              subtitle =\"em 2020\",\n              caption = \"Mendes,Jorge L.\") +\n        geom_label(size = 3) +\n    scale_x_continuous(limits = c(0,17000),\n                       labels = function(x){\n                       glue::glue(\"{x/1000}k\")}) +\n   \n    theme(plot.title = element_text(face = \"bold\"))\n\n\n\n\nEmbora o Brasil não tenha as maiores reservas de petróleo, ele pertence ao grupo dos maiores produtores.\nAgora podemos analizar a produção anual de petróleo do Brasil.\n\n#Texto com quebra de linha\nTexto <- paste(\n  strwrap(\"Aumento da extração de petróleo do Pré-Sal no ano de 2015\",\n          20),\n  collapse = \"\\n\")\n\nano_destacado <- Producao_internacional %>% \n  filter(ANO == 2015,PAÍS == \"Brasil\") %>%\n  mutate(label = glue::glue(\"{PRODUÇÃO}\"))\n\n\nProducao_internacional %>% filter(PAÍS ==\"Brasil\") %>% \n  ggplot() +\n   aes(x = ANO,y=round(PRODUÇÃO,2)) +\n \n  geom_line(size =1.2,colour = \"grey\" ) +\n    scale_x_continuous(\n      breaks =c(2011:2020)) +\n  labs(y = \"Milhares de Barris por dia\",x =\"Ano\",\n       title = \"\",\n       subtitle = \"\",\n       caption = \"Mendes, Jorge L.\") +\n  \n  geom_point(size = 3, \n             colour = \"grey\") +\n  \n  \n  \n  #Textos\n  annotate(\"text\",x = 2012 ,y =3000,size = 6,\n           label = \"BRASIL\", fontface = \"bold\",colour = \"#36674e\") +\n  annotate(\"text\",x = 2016 ,y =2300,size= 4,\n           label = Texto, fontface = \"bold\",colour = \"#243bd4\") +\n   \n  #destacar um ponto\n  ggrepel::geom_text_repel(\n    data = ano_destacado,\n    aes(x =ANO,y = PRODUÇÃO,label =label),\n    nudge_x = -0.5,\n    nudge_y = 50,\n    color = \"#243bd4\",\n    size = 5,\n    arrow = NULL\n  )\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\nQuem foram os maiores consumidores em 2020?\nCarregando os dados.\n\nconsumo_internacional <- readr::read_csv2(\"https://www.gov.br/anp/pt-br/centrais-de-conteudo/publicacoes/anuario-estatistico/arquivos-anuario-estatistico-2021-metadados-pdf-e-dados-abertos-csv/secao-1-panorama-internacional/dados-abertos-csv/anuario-2021-dados_abertos-tabela1-3.csv\")\n\nUsando o pacote knitr para formatar tabelas.\n\nconsumo_internacional %>% \n  filter(ANO ==2020) %>% select(2:3) %>%  \n  arrange(desc(`CONSUMO DE PETRÓLEO`)) %>% slice(1:10) %>% \n  head(10) %>% \n  knitr::kable(col.names = c(\"País\",\"Consumo de Petróleo (mil barris por dia)\"))\n\n\n\nPaís\nConsumo de Petróleo (mil barris por dia)\n\n\n\nEstados Unidos\n17178\n\n\nChina\n14225\n\n\nÍndia\n4669\n\n\nArábia Saudita\n3544\n\n\nJapão\n3268\n\n\nRússia\n3238\n\n\nCoreia do Sul\n2560\n\n\nBrasil\n2323\n\n\nCanadá\n2282\n\n\nAlemanha\n2045\n\n\n\n\n\nE no Brasil? Quais estados tem reserva de petróleo?\nCarregando dados\n\nBr_Reservas <- readr::read_csv2(\"https://www.gov.br/anp/pt-br/centrais-de-conteudo/publicacoes/anuario-estatistico/arquivos-anuario-estatistico-2021-metadados-pdf-e-dados-abertos-csv/secao-2-industria-nacional-do-petroleo-e-do-gas-natural/dados-abertos-csv/anuario-2021-dados_abertos-tabela2-3.csv\")\n\nAqui iremos somar as reservas marítimas e terrestres.\n\n#Vamos agrupar total das reservas(terra e mar)\nTotal_estados <- Br_Reservas %>% filter(ANO == 2020) %>% \n  group_by(`UNIDADES DA FEDERAÇÃO`) %>% \n  dplyr::summarise(\n    sum(\n      Total =`RESERVAS TOTAIS DE PETRÓLEO (EM MILHÕES DE BARRIS)`),\n      Count= n()\n    ) %>% \n  #renomeando as colunas\n  plyr::rename(replace =c(\"sum(Total = `RESERVAS TOTAIS DE PETRÓLEO (EM MILHÕES DE BARRIS)`)\"=\"Total\",\"UNIDADES DA FEDERAÇÃO\" = \"name_state\"))\n #Renomeando alguns itens\nTotal_estados$name_state[Total_estados$name_state ==\"Paraná5\"] <- \"Paraná\"\nTotal_estados$name_state[Total_estados$name_state ==\"Rio de Janeiro3\"] <- \"Rio De Janeiro\"\nTotal_estados$name_state[Total_estados$name_state ==\"Santa Catarina6\"] <- \"Santa Catarina\"\nTotal_estados$name_state[Total_estados$name_state ==\"São Paulo4\"] <- \"São Paulo\"\nTotal_estados$name_state[Total_estados$name_state ==\"Rio Grande do Norte\"] <- \"Rio Grande Do Norte\"\n#Formatando a tabela\nTotal <-Total_estados %>% \n  select(1:2) %>% kable(col.names = c(\"UF\",\"Total\"))\n\nTotal\n\n\n\nUF\nTotal\n\n\n\nAlagoas\n4.040435e+00\n\n\nAmazonas\n5.153600e+01\n\n\nBahia\n2.938644e+02\n\n\nCeará\n2.428873e-01\n\n\nEspírito Santo\n1.314880e+03\n\n\nMaranhão\n2.139806e-01\n\n\nParaná\n0.000000e+00\n\n\nRio Grande Do Norte\n2.662763e+02\n\n\nRio De Janeiro\n1.603287e+04\n\n\nSanta Catarina\n0.000000e+00\n\n\nSergipe\n1.947730e+02\n\n\nSão Paulo\n2.079593e+03\n\n\n\n\n\nPodemos apresentar os resultado na forma de mapa\nA biblioteca geobr nos force uma malha de pontos que podemos usar para construir mapas.\nCarregando os dados de 2017.\n\nMapa <-geobr::read_state(year = 2017)\n\nAgora podemos unir as tabelas\n\n# um pequeno malabarismo para plotar o mapa completo\nv1 <-c(\"Rio Grande Do Sul\",\"Minas Gerais\",\"Mato Grosso Do Sul\",\n       \"Mato Grosso\",\"Goiás\",\"Distrito Federal\",\"Piauí\",\"Paraíba\",\n       \"Pernambuco\",\"Rondônia\",\"Acre\",\"Roraima\",\"Pará\",\"Amapá\",\n       \"Tocantins\")\nv2 <-rep(0,15)\n# selecionar as colunas de interesse\nTotal_estados <- Total_estados %>% select(1:2)\n\n#adicionando linhas ao dataframe\nlinhas <-data.frame(name_state =v1,Total = v2)\n\nTotal_estados <- rbind(Total_estados,linhas)\n\n#Finalmente unindo as tabelas \nEstados <- merge(Mapa, Total_estados, by = c(\"name_state\"))\n\nPlotando o Gráfico.\n\n  Estados %>% ggplot() +\n    geom_sf(aes(fill=Total), color= \"black\", size=.15) +\n      labs(subtitle=\"Reservas Totais Estimadas em 2020\", size=8) +\n      scale_fill_distiller(palette = \"Oranges\",direction=1, \n                           name=\"Milhões de Barris\")"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Br.html",
    "href": "posts/Campeonato Brasileiro/Br.html",
    "title": "Campeonato Brasileiro",
    "section": "",
    "text": "This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\n\nsummary(cars)\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Br.html#pay-attention",
    "href": "posts/Campeonato Brasileiro/Br.html#pay-attention",
    "title": "Campeonato Brasileiro",
    "section": "Pay Attention",
    "text": "Pay Attention\nUsing callouts is an effective way to highlight content that your reader give special consideration or attention.\n:::\n```"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Br.html#including-plots",
    "href": "posts/Campeonato Brasileiro/Br.html#including-plots",
    "title": "Campeonato Brasileiro",
    "section": "Including Plots",
    "text": "Including Plots\nYou can also embed plots, for example:\n\n\n\n\n\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot."
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html",
    "title": "Campeonato Brasileiro",
    "section": "",
    "text": "Atualizado em 11/09/2022"
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html",
    "href": "posts/Saneamento/Saneamento.html",
    "title": "Saneamento no Estado de São Paulo",
    "section": "",
    "text": "Saneamento é um tema de extrema importâcia. Aqui o foco principal é fazer uma análise exploratória simples com dados públicos."
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html#bibliotecas",
    "href": "posts/Saneamento/Saneamento.html#bibliotecas",
    "title": "Saneamento no Estado de São Paulo",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(magrittr)\nlibrary(knitr)\nlibrary(geobr)\nlibrary(ggspatial)\nlibrary(sf)"
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html#os-dados",
    "href": "posts/Saneamento/Saneamento.html#os-dados",
    "title": "Saneamento no Estado de São Paulo",
    "section": "Os dados",
    "text": "Os dados\n\nOs dados foram obtidos da agência nacional de águas e saneamento básico ANA.\nFoi utilizado o Atlas Esgotos Situação 2013 - Remoção da Carga de Esgotos Gerada na Sede Municipal e o pacote geobr (Pereira and Goncalves 2021) para acessar informações sobre os dados espaciais do Brasil.\n\ndados <- readr::read_delim(\"Atlas_Esgoto2013.csv\",delim = ',')\n\n\nglimpse(dados)\n\nRows: 5,570\nColumns: 14\n$ FID        <dbl> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1~\n$ MUN_CD_MUN <dbl> 1100015, 1100023, 1100031, 1100049, 1100056, 1100064, 11000~\n$ MUN_NM_MUN <chr> \"Alta Floresta D Oeste\", \"Ariquemes\", \"Cabixi\", \"Cacoal\", \"~\n$ MUN_UF     <chr> \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\",~\n$ MUN_NM_PRE <chr> \"Serviço Autônomo de Água e Esgoto\", \"Companhia de Águas e ~\n$ MUN_SIGLA_ <chr> \"SAAE\", \"CAERD\", \"PM\", \"SAAE\", \"PM\", \"PM\", \"PM\", \"PM\", \"PM\"~\n$ MUN_POPU_2 <dbl> 14735, 85770, 2771, 67665, 15276, 14097, 2665, 8689, 22741,~\n$ MUN_ICS    <dbl> 1.4244810, 2.0176413, 0.3713331, 0.0000000, 0.6727235, 1.02~\n$ MUN_IFSUTI <dbl> 1.8468146, 8.5762823, 0.6312662, 16.1786793, 19.6892988, 4.~\n$ MUN_ISCST  <dbl> 96.728704, 89.406076, 98.997401, 28.821321, 79.637978, 94.9~\n$ MUN_C_GERA <dbl> 795, 4631, 149, 3653, 824, 761, 143, 469, 1228, 2088, 2027,~\n$ MUN_C_REMA <dbl> 786, 4393, 149, 1791, 727, 742, 138, 445, 1126, 1907, 1986,~\n$ MUN_EFIC_1 <dbl> 1.1080888, 5.1457694, 0.3787597, 50.9572076, 11.8135793, 2.~\n$ MUN_ICT_FI <dbl> 0.000000, 0.000000, 0.000000, 55.000000, 0.000000, 0.000000~"
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html#manipulando-as-bases",
    "href": "posts/Saneamento/Saneamento.html#manipulando-as-bases",
    "title": "Saneamento no Estado de São Paulo",
    "section": "Manipulando as Bases",
    "text": "Manipulando as Bases\nRenomeando as colunas (consultei o aplicativo do ANA).\n\ndados <- dados %>% \n    dplyr::rename( \n        c(\"code_muni\" = \"MUN_CD_MUN\",\"municipio\"=\"MUN_NM_MUN\" ,\n          \"uf\"=\"MUN_UF\", \"prestador_servico\"= \"MUN_NM_PRE\" ,\n          \"sigla_prestador\"=\"MUN_SIGLA_\"  ,\n          \"populacao2013\" =\"MUN_POPU_2\" , \n                \n          \"Parcela_População_Com_Coleta_Sem_Tratamento(%)\")= =\n            \"MUN_ICS\",\n                \n          \"Parcela_População_Com_Solução_Individual(%)\"(=)\" =\n            \"MUN_IFSUTI\" ,\n                \n          \"Parcela_População_Sem_Coleta_Sem_Tratamento(%)\")= =\n            \"MUN_ISCST\",\n                \n          \"Parcela_População_Com_Coleta_Com_Tratamento(%)\")= =\n            \"MUN_ICT_FI\",\n                \n          \"Carga_Gerada\"= \"MUN_C_GERA\",\n          \"Carga_Remanescente\" =\"MUN_C_REMA\"  ,\n          \"Remoção_Carga_Orgânica(DBO)(%)\"=\"MUN_EFIC_1\"))\"))\n\nPodemos gerar tabelas com o pacote knitr para gerar tabelas.\nQuais cidades geram maior carga de esgoto no estado de são paulo?\n\ndados %>% filter(uf == \"SP\") %>% \n  select(c(\"municipio\",\"Carga_Gerada\")) %>% \n  arrange(desc(Carga_Gerada)) %>% \n  slice(1:10) %>% \n  knitr::kable(col.names = \n                 c(\"Municípios\"\"\"Carga Gerada Total (kgDBO/dia)\")),\n               \"simple\",caption = \"Estado de São Paulo\"))\n\n\nEstado de São Paulo\n\nMunicípios\nCarga Gerada Total (kgDBO/dia)\n\n\n\nSão Paulo\n604822\n\n\nGuarulhos\n65986\n\n\nCampinas\n57323\n\n\nSão Bernardo do Campo\n43263\n\n\nOsasco\n40435\n\n\nSanto André\n38211\n\n\nSão José dos Campos\n35351\n\n\nRibeirão Preto\n32560\n\n\nSorocaba\n31355\n\n\nSantos\n22833\n\n\n\n\n\nCarregando os dados do geobr para o estado de São Paulo.\n\nmapa <- geobr::read_municipality(code_muni = 35,year = 2018)\n\nUsing year 2018\n\n\nUnindo as tabelas\n\nsp <- dados %>% filter(uf ==\"SP\") %>% merge(mapa)\nnrow(sp) # verificando se possui as 645 cidades do estado de sp\n\n[1] 645\n\n\nAgora podemos gerar mapas com os pontos geom.\nQuais cidades geram mais carga de esgoto no estado de São Paulo?\n\nsp  %>% ggplot() +\n  geom_sf(aes(fill = Carga_Gerada, geometry = geom)) + \n  labs(title = \"Situação do Estado de São Paulo\"lo\",\n       subtitle = \"Carga Total Gerada 2013\") +\n  scale_fill_distiller(palette = \"Reds\",direction = 1,\n                       name= \"KgDBO/dia\") +\n  theme(axis.title=element_blank(),\n                   axis.text=element_blank(),\n                   axis.ticks=element_blank())\n\n\n\n\nPodemos verificar uma região específica ( como um conjunto de cidades). A forma mais segura é utilizar os códigos dos municípios, algumas cidades compartilham o mesmo nome.\nQual a porcentagem da população com coleta e tratamento de esgoto na região do grande ABC?\nAproveitei e adicionei o nome dos municípios, eixos das coordenadas, escala e a indicação do norte.\n\nlistaABC = list(3548708, 3547809, 3529401, 3513801, 3548807, 3543303, 3544103)\n\nsp %>%  filter(code_muni %in% listaABC) %>%\n  ggplot() + \n  geom_sf(aes(fill = `Parcela_População_Com_Coleta_Com_Tratamento(%)`)`,\n              geometry = geom)) +\n  \n  geom_sf_label(aes(label = municipio,geometry =geom),\n                label.padding = unit(0.5,\"mm\"),\n                size = 2) +\n  \n  \n  labs(title = \"Parcela da População Com Coleta e Com Tratamento\"o\",\n       subtitle = \"Região do Grande ABC, 2013 \"\",\n       x = \"Longitude\",y =\"Latitude\") +\n  \n  scale_fill_distiller(palette = \"Greens\",direction = 1,\n                       name= \"(%)\") +\n  annotation_north_arrow(location = \"br\") +\n  annotation_scale(location =\"bl\"\n                   )\n\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data"
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html#referências",
    "href": "posts/Saneamento/Saneamento.html#referências",
    "title": "Saneamento no Estado de São Paulo",
    "section": "Referências",
    "text": "Referências\n\nBea Milz"
  },
  {
    "objectID": "posts/Saneamento/Saneamento.html#ver-também",
    "href": "posts/Saneamento/Saneamento.html#ver-também",
    "title": "Saneamento no Estado de São Paulo",
    "section": "Ver também",
    "text": "Ver também\n\nBea Milz"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#objetivo",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#objetivo",
    "title": "Campeonato Brasileiro",
    "section": "Objetivo",
    "text": "Objetivo\nExplorar a biblioteca brasileirão (Amorim 2022) . É uma boa base para praticar, principalmente, manipulações de dataframe.\nEla consegue, além de outras coisas, retornar jogos, a data, o placar e os clubes envolvidos desde 2003 no campeonato brasileiro de futebol."
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#bibliotecas",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#bibliotecas",
    "title": "Campeonato Brasileiro",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr) #tratamento de dados\nlibrary(tidyr) #tratamento de dados\n\nlibrary(magrittr) #o pipe antigo\nlibrary(purrr) #programação funcional\nlibrary(lubridate) #tratar datas\nlibrary(knitr) #formatação de tabelas\n\nlibrary(brasileirao) #base de dados utilizados\n\nlibrary(ggplot2) #gráficos\nlibrary(treemap) #gráficos\n\nlibrary(jpeg) #adicionar imagens\nlibrary(patchwork)  #adicionar imagens"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#mão-na-massa",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#mão-na-massa",
    "title": "Campeonato Brasileiro",
    "section": "Mão na Massa",
    "text": "Mão na Massa\nCarregando dados.\n\nBr &lt;- brasileirao::matches\n\nPodemos expor os resultados na forma de tabela.\n\nknitr::kable(head(Br),align = \"lccrr\")\n\n\n\nseason\ndate\nhome\nscore\naway\n\n\n\n2003\n2003-03-29\nAthletico PR\n2x0\nGrêmio\n\n\n2003\n2003-03-29\nGuarani\n4x2\nVasco\n\n\n2003\n2003-03-30\nCorinthians\n0x3\nAtlético MG\n\n\n2003\n2003-03-30\nGoiás\n2x2\nPaysandu\n\n\n2003\n2003-03-30\nCriciúma\n2x0\nFluminense\n\n\n2003\n2003-03-30\nCruzeiro\n2x2\nSão Caetano\n\n\n\n\n\nVerificando os tipos de variáveis das colunas.\n\nglimpse(Br)\n\nRows: 8,026\nColumns: 5\n$ season &lt;dbl&gt; 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 200~\n$ date   &lt;date&gt; 2003-03-29, 2003-03-29, 2003-03-30, 2003-03-30, 2003-03-30, 20~\n$ home   &lt;chr&gt; \"Athletico PR\", \"Guarani\", \"Corinthians\", \"Goiás\", \"Criciúma\", ~\n$ score  &lt;chr&gt; \"2x0\", \"4x2\", \"0x3\", \"2x2\", \"2x0\", \"2x2\", \"1x1\", \"0x0\", \"1x1\", ~\n$ away   &lt;chr&gt; \"Grêmio\", \"Vasco\", \"Atlético MG\", \"Paysandu\", \"Fluminense\", \"Sã~\n\n\nRealizando algumas manipulações para obter resultados dos jogos a partir de 2010.\n\nTabela_extendida &lt;- Br  %&gt;% filter(season &gt;=2010)  %&gt;% \n  separate(score,\n           c(\"Placar_Mandante\",\"Placar_Visitante\"),\n           sep = \"x\",\n           convert = TRUE,\n           remove = FALSE\n    \n  ) %&gt;% \n  mutate(\n    Mandante = case_when(\n      Placar_Mandante &gt; Placar_Visitante~\"Venceu\",\n      Placar_Mandante &lt; Placar_Visitante~\"Perdeu\",\n      Placar_Mandante == Placar_Visitante~\"Empate\"\n    ),\n     Visitante = case_when(\n      Placar_Mandante &lt; Placar_Visitante~\"Venceu\",\n      Placar_Mandante &gt; Placar_Visitante~\"Perdeu\",\n      Placar_Mandante == Placar_Visitante~\"Empate\"\n    )\n  )\n\nA ideia aqui é selecionar um clube e fazer as análises a partir dessa escolha. Vamos criar uma função para selecionar um time.\n\nClube&lt;-function(dataframe,Time){\n  #selecionar o clube quando ele é mandante\n        TimeMandante &lt;-dataframe %&gt;% filter(home==Time) %&gt;% \n            select(season,date,home,Placar_Mandante,\n            Placar_Visitante,Mandante,away) %&gt;% \n            rename(\n                    \"clube\"=\"home\",\n                    \"Gols_Pro\"=\"Placar_Mandante\",\n                    \"Gols_Contra\"=\"Placar_Visitante\",\n                    \"Resultado\"=\"Mandante\",\n                    \"adversario\" =\"away\") %&gt;% \n            mutate(mando = \"Mandante\")\n  \n  #selecionar o clube quando ele é visitante\n        TimeVisitante &lt;- dataframe %&gt;% \n            filter(away==Time) %&gt;% \n            select(season,date,away,Placar_Visitante,\n            Placar_Mandante,Visitante,home) %&gt;% \n            rename(\n                    \"clube\"=\"away\",\n                    \"Gols_Pro\"=\"Placar_Visitante\",\n                    \"Gols_Contra\"=\"Placar_Mandante\",\n                    \"Resultado\"=\"Visitante\",\n                     \"adversario\"=\"home\") %&gt;% \n            mutate(mando = \"Visitante\")\n  \n  #Unindo as tabelas\n        Resultados &lt;-rbind(TimeMandante,TimeVisitante)\n  \n  return(Resultados)\n  \n}\n\nSelecionando um time.\nO interessante é selecionar um clube que jogou muitas edições para ter uma boa quantidade de dados. Convenientemente foi selecionado o Corinthians.\n\n\n\n\n\nTimao&lt;-Clube(dataframe= Tabela_extendida,Time =\"Corinthians\")\n\nÉ interessante adicionar os pontos obtidos em cada partida.\n\nTimao &lt;- Timao %&gt;% mutate(\n  Pontos = case_when(\n  Resultado ==\"Venceu\"~3,\n  Resultado ==\"Empate\"~1,\n  Resultado ==\"Perdeu\"~0,\n))\n\nUsando o pacote lubridate é possível tratar datas, obtendo informações sobre o dia,dia da semana, mês e ano de forma isolada.\n\n#Timao$dia_Mes &lt;- lubridate::day(Timao$date)\nTimao$Mes &lt;- lubridate::month(Timao$date, label = TRUE)\n#Timao$NdiaSemana &lt;- lubridate::wday(Timao$date)\n\nQual o número de vitórias, empates e derrotas da última década?\n\nTimao %&gt;% filter(!is.na(Pontos)) %&gt;% count(Resultado) %&gt;%  \n  treemap(index = c(\"n\",\"Resultado\"),\n          vSize = \"n\",\n          align.labels=list(c(\"center\", \"center\"),c(\"center\", \"top\")),\n          title = \"Resultados do Corinthians desde 2010\",\n          fontsize.labels=c(15,12),\n          palette = c(\"#cfc6c6\",\"#3d3a3a\",\"#0a0a0a\")\n           \n           )\n\n\n\n\nCom a função group_by e summarise podemos agrupar os dados.\n\nDadosAgg &lt;- Timao %&gt;% \n\n  filter(!is.na(Pontos)) %&gt;% \n\n  group_by(Mes)%&gt;% \n\n  summarise(\n\n    MediaPontos = round(mean(Pontos),2),\n    GolsPro = sum(Gols_Pro),\n    GolsContra =sum(Gols_Contra)) %&gt;%\n\n    arrange(desc(Mes))\n\nDadosAgg %&gt;% knitr::kable(col.names =\n                            c(\"Mês\",\"Pontos\",\"Gols Pro\",\"Gols Contra\"))\n\n\n\nMês\nPontos\nGols Pro\nGols Contra\n\n\n\ndez\n1.11\n16\n19\n\n\nnov\n1.82\n85\n58\n\n\nout\n1.40\n87\n80\n\n\nset\n1.37\n89\n77\n\n\nago\n1.56\n88\n69\n\n\njul\n2.00\n81\n35\n\n\njun\n1.71\n62\n38\n\n\nmai\n1.84\n53\n32\n\n\nabr\n1.78\n16\n9\n\n\nfev\n1.00\n6\n7\n\n\njan\n1.20\n9\n8\n\n\n\n\n\nQual mês, em média, fez mais pontos?\n\n DadosAgg%&gt;% \n    \n    \n    ggplot(aes(x =MediaPontos ,y =Mes, label = MediaPontos)) +\n\n    geom_col(fill = \"gray\")+\n\n     \n    geom_text(\n            position = position_stack(vjust =1.05),\n            color=\"#030202\") +\n    \n    labs(x = \"Pontos\",y = \"Mês\", title = \"Média de Pontos em Cada Mês\",\n         subtitle = \"valores a partir de 2010\") +\n    theme(axis.text.x = element_blank(),axis.ticks.x=element_blank(),\n          axis.text.y =element_text(face =\"bold\",\n                                    colour = \"#030202\"))\n\n\n\n\nEm quais mêses, fez e tomou ,mais gols?\n\nDadosAgg %&gt;%  ggplot() +\n    \n    geom_col(aes(x = -GolsPro ,y =Mes), fill=\"#424d6b\") +\n\n     \n    geom_text(aes(x = -GolsPro ,y =Mes,label =GolsPro),\n            position = position_stack(vjust =0.5),\n            color =\"#ced2de\") +\n    \n    geom_col(aes(x = GolsContra,y =Mes), \n              fill=\"#806630\") +\n\n     \n    geom_text(aes(x =GolsContra ,y =Mes,label =GolsContra),\n            position = position_stack(vjust =0.5),\n            color=\"#030202\") +\n   annotate(\"text\",x = -50 ,y =2,label =\"Gols Pro\",\n            color =\"#424d6b\") +\n   annotate(\"text\",x = 50 ,y =2,label =\"Gols Contra\",\n            color =\"#806630\") +\n    \n    \n    labs(x = \"Gols\",y = \"Mês\", title = \"Total de Gols por Mês\",\n         subtitle = \"valores a partir de 2010\") +\n    theme(axis.text.x = element_blank(),\n          axis.ticks.x=element_blank(),\n          axis.text.y =element_text(face =\"bold\",\n                                    colour = \"#030202\"))\n\n\n\n\nQual o desempenho das últimas temporadas?\n\nano &lt;- c(2011,2015,2017)\npontuacao &lt;-\n  Timao %&gt;% filter(!is.na(Pontos)) %&gt;% \n  group_by(season) %&gt;% \n  summarise(Pontos = sum(Pontos)) %&gt;% \n  mutate(Titulo = ifelse(season %in% ano, \"Campeão\", \"Não Ganhou\")) \n\n\nTexto &lt;- paste(\n  strwrap(\"A temporada de 2022 ainda não foi concluída\",\n          20),\n  collapse = \"\\n\")\n\npath &lt;-\"escudo1.jpg\"\nimg &lt;- readJPEG(path,native = TRUE)\n\n\npontuacao %&gt;% \n  ggplot() +\n    geom_line(aes(x = season, y = Pontos),size =1.4,colour =\"grey\") +\n    scale_x_continuous(breaks = c(2010:2022)) +\n    geom_point(aes(x = season, y = Pontos),size = 2,color=\"grey\") +\n    \n    geom_point(\n      aes(x = season,y=Pontos, color =Titulo, size= Titulo)) +\n    \n    scale_colour_manual(values = c(\"#0a0a0a\",\"#b3a6a6\")) +\n\n    scale_size_manual(values = c(3,2)) +\n    \n    geom_line(aes(x = c(2010:2022),y = mean(`Pontos`)),\n              linetype =2) +  \n  \n    labs(x =\"Temporada\",title = \"Desempenho do Clube\") +\n    \n    theme(axis.text.x = element_text(angle = 90)) +\n    \n    annotate(\"text\",x = 2011 ,y =60,size = 2,\n           label = \"Média\", fontface = \"bold\",colour = \"black\") +\n    annotate(\"text\",x = 2018 ,y =35,size = 4,\n           label = Texto, fontface = \"bold\",colour = \"red\") +\n    inset_element(p = img,\n                left = 1.00,\n                bottom = 0.65,\n                right = 1.35,\n                top = 1.15)"
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#conclusão",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#conclusão",
    "title": "Campeonato Brasileiro",
    "section": "Conclusão",
    "text": "Conclusão\nA biblioteca brasileirao é excelente . Foi possível extrair bastante informação. Ela fornece de forma simples os dados gerais sobre as partidas, infelizmente ela não trás informações como número de cartões, tempo de jogo sem interrupções, posse bola, e entre outras. Não é terra arrasada, pois outros dados de fontes distintas podem ser adicionados para complementar as análises."
  },
  {
    "objectID": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#ver-também",
    "href": "posts/Campeonato Brasileiro/Campeonato Brasileiro.html#ver-também",
    "title": "Campeonato Brasileiro",
    "section": "Ver também",
    "text": "Ver também\n\nr - graph - gallery\nBlog Curso -R"
  },
  {
    "objectID": "posts/Premier League/Premier League.html",
    "href": "posts/Premier League/Premier League.html",
    "title": "Premier League",
    "section": "",
    "text": "a <- c(0:40)\n print(a)\n##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n## [26] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40"
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html",
    "href": "posts/Twitter/API_Twitter.html",
    "title": "Como usar API do Twitter",
    "section": "",
    "text": "API ou interface de programação de aplicação é basicamente uma ferramenta que estabelece uma comunicação entre sistemas. Nela é possível que realizar troca de informações de forma segura utilizando diferentes linguagens de programação.\nO Twitter fornece API para consumo de dados para algumas lnguagem como python, R, entre outras. O R possui uma biblioteca específica para isso chamada rtweet (Kearney 2019)."
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#primeiros-passos",
    "href": "posts/Twitter/API_Twitter.html#primeiros-passos",
    "title": "Como usar API do Twitter",
    "section": "Primeiros passos…",
    "text": "Primeiros passos…\nInicialmente devesse criar uma conta no Twitter e em seguida criar uma conta de desenvolvedor na própria plataforma. Ao criar um projeto e um aplicativo serão geradas chaves de acesso para a requisição de dados via API.\n\n\nPortal do Desenvolvedor\n\n\n\n\n\n\n\n\nAo criar a conta lembre-se de ativar a autenticação em dois fatores."
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#bibliotecas",
    "href": "posts/Twitter/API_Twitter.html#bibliotecas",
    "title": "Como usar API do Twitter",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\n#install.packages(\"rtweet\")\n#install.packages(\"wordcloud\")\n#install.packages(\"tm\")\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(magrittr)\nlibrary(lubridate)\nlibrary(knitr)\nlibrary(rtweet)\nlibrary(wordcloud)\nlibrary(tm)\n\nExistem 3 formas simples de se fazer a autenticação:\n\n\nUsando as chaves\nLogin\nUsando rtweet app\n\n\n\n\nNa função mencionada create_token basta inserir os argumentos fornecidos na hora de criar o app.\n\napp\nconsumer key\nconsumer secret\naccess token\naccess secret\n\n\n\n\n\nCaso tenha algum tipo de problema com o primeiro método, é possível utilizar a mesma função create_token sem argumentos. Neste caso você será levado a uma página de login do Twitter e um código de autenticação será enviado um código para o seu celular.\n\n\n\n\n\nOutra opção é usar a função rtweet_app, nesse caso uma tela e será necessário fornecer a Bearer token.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEscolha\n\n\n\n\n\nEu tive problemas com a primeiro e terceiro método de autenticação. Uma análise mais profunda da documentação do pacote possa revelar a solução mas na ausência de tempo escolhi o que funcionou sem ter nenhum erro.\nA função create_token foi descontinuada a partir da versão 1.0.0 do pacote rtweet e a função rtweet_app é mais indicada para versão 1.0.2 .\n\n\n\n\n\n\n\n\n\nCuidado!!! Sempre proteja suas chaves.\n\n\n\n\n\nEsse não é o caso mas existem API’s que são pagas, além do prejuízo financeiro, a ideia de terceiros utilizarem para fins duvidosos já causa preocupação. Caso interesse em disponizibilizar seus scripts existem métodos seguros para proteger senhas e chaves, mas como não é o foco dessa postagem tem esse blog."
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#ver-também",
    "href": "posts/Twitter/API_Twitter.html#ver-também",
    "title": "Como usar API do Twitter",
    "section": "Ver Também",
    "text": "Ver Também\n\nCéline Van den Rul"
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#manipulações",
    "href": "posts/Twitter/API_Twitter.html#manipulações",
    "title": "Como usar API do Twitter",
    "section": "Manipulações",
    "text": "Manipulações\nApós a autenticação podemos iniciar nossas análises .\nCom a função search_tweets ajuda a fazer busca por assuntos ou perfis. Podemos escolher o número de tweets, o idioma, entre outras opções.\nNesse caso trouxemos 3000 tweets com o assunto seleção.\n\nselecao <- search_tweets(\"seleção\", n=3000)\n\nAntes de fazer visualizações devemos fazer uma limpeza nos dados.\n\n# Remove retweets e replies\nselecao_tweets_organic <- selecao %>% filter(\n  retweeted == FALSE, is.na(in_reply_to_status_id)\n                                             ) \n# converte o tipo \nselecao_tweets_organic$full_text <- as.character(\n selecao_tweets_organic$full_text)\n\n#selecionar só as colunas que serão utilizadasas\nselecao_tweets_organic <-selecao_tweets_organic %>% select(created_at,full_text,retweet_count,favorite_count,display_text_range,lang)\n\n# removendo palavras que não fazem sentido para análisese\nselecao_tweets_organic$full_text <- gsub(\"com\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"que\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"pra\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"blimag\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"tô\"\"\"\"\"selecao_tweets_organic$full_text))\nselecao_tweets_organic$full_text <- gsub(\"por\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"bolsonaro\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"uma\",\"\",selecao_tweets_organic$full_text)\nselecao_tweets_organic$full_text <- gsub(\"Bolsonaro\",\"\",selecao_tweets_organic$full_text)\n\nUma nuvem de palavras é um tipo de visualização muito boa para dados textuais e para executar essa tarefa temos a biblioteca wordcloud nela podemos passar uma coluna de dataframe como dado de entrada.\n\nset.seed(1234) # reprodutibilidade\n\n\nwordcloud(selecao_tweets_organic$full_text, \n          min.freq=5, scale=c(3.5, .5), \n          random.order=FALSE, rot.per=0.45, \n          colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\nPodemos fazer análises com base no horário em que o tweet foi criado.\n\nselecao_tweets_organic$hora_criada <-lubridate::hour(selecao_tweets_organic$created_at)\n\nEm média qual horário teve mais Retweet, Favoritoe e Tamanho de Texto?\n\nselecao_tweets_organic %>% group_by(hora_criada) %>%\n  summarise(round(mean(retweet_count)),\n            round(mean(favorite_count)),\n            round(mean(display_text_range))) %>% \n  kable(col.names = c(\"Hora\",\"Retweet\",\"Favorito\",\"Tamanho do Texto\"),caption = \"Médias Referentes ao Assunto Seleção\")o\")\n\n\nMédias Referentes ao Assunto Seleção\n\nHora\nRetweet\nFavorito\nTamanho do Texto\n\n\n\n0\n417\n0\n119\n\n\n1\n173\n2\n133\n\n\n2\n91\n1\n126\n\n\n3\n169\n0\n131\n\n\n4\n241\n1\n133\n\n\n5\n123\n1\n124\n\n\n6\n148\n1\n134\n\n\n7\n124\n14\n138\n\n\n8\n223\n3\n134\n\n\n9\n87\n14\n139\n\n\n10\n81\n6\n131\n\n\n11\n91\n34\n129\n\n\n12\n195\n44\n126\n\n\n15\n176\n4846\n151\n\n\n\n\n\nEscolhendo um perfil dessa vez. Aproveitando que é semana de champions escolhi o Vinícius Junior do Real Madrid.\n\nvinijr <- search_tweets(\"@vinijr\", n = 3000)\n\nQuais idiomas presentes nos tweets?\n\nunique(vinijr$lang)\n\n [1] \"und\" \"es\"  \"en\"  \"it\"  \"ht\"  \"fr\"  \"pt\"  \"in\"  \"cy\"  \"ar\"  \"ca\"  \"eu\" \n[13] \"fi\"  \"nl\"  \"tl\"  \"et\"  \"lv\"  \"no\"  \"tr\" \n\n\nDesconsiderando o português qual a porcetagem de presença dos tweets?\n\nvinijr %>% filter(lang != \"pt\") %>% \n  group_by(lang) %>% \n  summarise(contagem=n()) %>%\n  arrange(desc(contagem)) %>% \n  slice(1:5) %>%\n  mutate(\n    langEx = case_when(lang ==\"ar\"~\"Árabe\"\",\n                     lang ==\"es\"~\"Espanhol\",\n                     lang ==\"fr\"~\"Francês\"\",\n                     lang ==\"en\"~\"Inglês\"\", \n                     lang ==\"und\"~\"Não Detectado\"\",\n                     )) %>% \n   \n  mutate(Perc = round(contagem /sum(contagem)*100 ,2 )) %>% \n  ggplot(aes(x= langEx,y =Perc,label = Perc)) +\n  geom_col(fill =\"gray\") +\n    \n  geom_text(position = position_stack(vjust =1.05),\n           color=\"#030202\") +\n  labs(\n    title= \"Os 5 Idiomas mais Presentes nos Tweets do @vinijr\",\n       subtitle = \"Desconsiderando o Português\"\", x=\"\"\", \n       y ='Porcentagem (%)') +\n   theme(axis.ticks.x=element_blank(),\n          axis.text.y =element_blank())"
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#conclusão",
    "href": "posts/Twitter/API_Twitter.html#conclusão",
    "title": "Como usar API do Twitter",
    "section": "Conclusão",
    "text": "Conclusão\nEmbora eu tenha descartado a maioria das colunas, estou impressionado pelo volume de informação que a API disponibiliza para o usuário (43 colunas) um leque absurdo de análises que podem ser feitas. A parte mais complexa é estabelecer a conexão com a API mas uma vez feita basta se atentar no tempo de validade das chaves."
  },
  {
    "objectID": "posts/Twitter/API_Twitter.html#autenticando",
    "href": "posts/Twitter/API_Twitter.html#autenticando",
    "title": "Como usar API do Twitter",
    "section": "Autenticando",
    "text": "Autenticando\n\ntwitter_token = create_token()\nauth_as(twitter_token)"
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html",
    "href": "posts/Governos do Reino Unido/Web Scraping.html",
    "title": "Extraindo dados da wikipedia",
    "section": "",
    "text": "Venho me interessando pelo tema de raspagem de dados (Web Scraping) e resolvi trazer exemplo “simples” de como faze-lo. A ideia aqui é extrair os dados da página da Wikipédia, realizar o tratamento e fazer análise exploratória."
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#bibliotecas",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#bibliotecas",
    "title": "Extraindo dados da wikipedia",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(forcats)\nlibrary(ggalt)\nlibrary(treemap)\nlibrary(magrittr) # pipe\nlibrary(lubridate)# tratamento de datas\nlibrary(knitr) # formatação de tabelasas\nlibrary(rvest) # raspagem de dados"
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#carregando-os-dados",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#carregando-os-dados",
    "title": "Extraindo dados da wikipedia",
    "section": "Carregando os dados",
    "text": "Carregando os dados\nPara carregar os dados é necessário o Link da página da wikipédia e a tag da tabela. Para fazer isso basta clicar com o botão direito próxima a tabela desejada e escolher a opção inspecionar elemento, em seguida identificar tag da tabela e copiar seu XPath como mostra a figura 1.\n\n\nFígura 1\n\n\nCom essas informações podemos fazer a extração.\n\nurl <- \"https://pt.wikipedia.org/wiki/Lista_de_primeiros-ministros_do_Reino_Unido\"\ntag <- '//*[@id=\"mw-content-text\"]/div[1]/table[3]'\n\ndados <- url %>%  \n  rvest::read_html() %>% \n  rvest::html_node(xpath = tag) %>%\n  rvest::html_table()\n\nPodemos verificar o tipo de estrutura.\n\nclass(dados)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nPodemos inspessionar os nomes das colunas e os tipos de dados que estão presentes.\n\ncolnames(dados)\n\n [1] \"N.º\"                                                \n [2] \"Primeiro-ministro (Nascimento–Falecimento)\"         \n [3] \"Primeiro-ministro (Nascimento–Falecimento)\"         \n [4] \"Mandato (Duração em anos e dias)\"                   \n [5] \"Mandato (Duração em anos e dias)\"                   \n [6] \"Partido\"                                            \n [7] \"Partido\"                                            \n [8] \"Cargos ministeriais ocupados como primeiro-ministro\"\n [9] \"Monarca (Reino)\"                                    \n[10] \"Ref.\"                                               \n\n\n\nglimpse(dados)\n\nRows: 188\nColumns: 10\n$ N.º                                                   <chr> \"1\", \"1\", \"1\", \"~\n$ `Primeiro-ministro (Nascimento–Falecimento)`          <chr> \"\", \"\", \"\", \"\", ~\n$ `Primeiro-ministro (Nascimento–Falecimento)`          <chr> \"Sir Robert Walp~\n$ `Mandato (Duração em anos e dias)`                    <chr> \"3 de abril de 1~\n$ `Mandato (Duração em anos e dias)`                    <chr> \"1722\", \"1727\", ~\n$ Partido                                               <chr> \"\", \"\", \"\", \"\", ~\n$ Partido                                               <chr> \"Whig\", \"Whig\", ~\n$ `Cargos ministeriais ocupados como primeiro-ministro` <chr> \"Chanceler do Te~\n$ `Monarca (Reino)`                                     <chr> \"Jorge I  (1714–~\n$ Ref.                                                  <chr> \"[20]\", \"[20]\", ~\n\n\nAqui termina a parte simples."
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html",
    "href": "posts/Copa do Mundo/Copa do Mundo.html",
    "title": "Usando R para acessar google sheet",
    "section": "",
    "text": "O (Bryan 2022) é um pacote que pode acessas dados de planilhas do google sheets via API. É interessante armazenar dados na nuvem, pois economiza memória e te permite acessa-los de outros locais de uma forma segura."
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html#bibliotecas",
    "href": "posts/Copa do Mundo/Copa do Mundo.html#bibliotecas",
    "title": "Usando R para acessar google sheet",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(googlesheets4)\n\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(magrittr)\nlibrary(purrr)\n\nlibrary(ggplot2)\nlibrary(ggbump)"
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html#autenticação",
    "href": "posts/Copa do Mundo/Copa do Mundo.html#autenticação",
    "title": "Usando R para acessar google sheet",
    "section": "Autenticação",
    "text": "Autenticação\nPrimeiro armazenar o link da planilha.\n\nurl_dados <- \"https://docs.google.com/spreadsheets/d/1urL93VWfy0R_hqNjNq-fdQdXF6Ta9L38k5wVuubL9Zw/edit#gid=659891394\"\n\nAo executar qualquer função desse pacote você será levado a seguinte página do seu Browser.\n\n\nEscolher um email para autênticação\n\n\nDar a permissão para editar, criar excluir dados da planilha.\n\n\nAutorização para a manipulação da planilha.\n\n\nApós a primeira autênticação as requisições passam ser autorizadas via console do RStudio.\nA função sheet_properties mostra quais são as planilhas que estão na pasta de trabalho.\n\nsheet_properties(url_dados)\n\n# A tibble: 25 x 8\n   name        index         id type  visible grid_rows grid_columns data  \n   <chr>       <int>      <int> <chr> <lgl>       <int>        <int> <list>\n 1 País            0          0 GRID  TRUE         1000           26 <NULL>\n 2 Copa_Final      1  739370969 GRID  TRUE         1000           26 <NULL>\n 3 Artilheiros     2  332312744 GRID  TRUE         1000           26 <NULL>\n 4 Disputas        3 1811446063 GRID  TRUE         1000           26 <NULL>\n 5 1930            4 1245394281 GRID  TRUE         1000           26 <NULL>\n 6 1934            5  199002872 GRID  TRUE         1000           26 <NULL>\n 7 1938            6  659891394 GRID  TRUE         1000           26 <NULL>\n 8 1950            7 1547033404 GRID  TRUE         1000           26 <NULL>\n 9 1954            8  946131332 GRID  TRUE         1000           26 <NULL>\n10 1958            9   35115059 GRID  TRUE         1000           26 <NULL>\n# ... with 15 more rows"
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html#manipulações",
    "href": "posts/Copa do Mundo/Copa do Mundo.html#manipulações",
    "title": "Usando R para acessar google sheet",
    "section": "Manipulações",
    "text": "Manipulações\nExiste conjunto de planilhas nesta base e podemos uni-las para criar uma tabela só.\n\nlista_de_copas  <-list(\"1930\",\"1934\",\"1938\",\"1950\",\"1954\",\n                       \"1958\",\"1962\",\"1966\",\"1970\",\"1974\",\n                       \"1978\",\"1982\",\"1986\",\"1990\",\"1994\",\n                       \"1998\",\"2002\",\"2006\",\"2010\",\"2014\",\n                       \"2018\")\n\ndf <-data.frame()\n\nfor(i in lista_de_copas){\n  \n  df <- rbind(df,read_sheet(url_dados,sheet = i))\n  \n  \n}\n\n\n\n\n\n\n\nTipo de Arquivo\n\n\n\n\n\nÉ comum confundir o tipo de extensão do arquivo. A biblioteca {googlesheet4} é para ler e manipular planilhas criadas utilizando google sheets e não planilhas xlsx (excel microsoft).\n\n\n\nVerificando o tipo de dado.\n\nglimpse(df)\n\nRows: 457\nColumns: 9\n$ Ano           <dbl> 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 19~\n$ Posição       <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2, 3, 4, 5~\n$ NumJogos      <chr> \"4\", \"5\", \"3\", \"3\", \"3\", \"2\", \"3\", \"2\", \"2\", \"2\", \"2\", \"~\n$ Vitórias      <dbl> 4, 4, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 4, 3, 3, 2, 1, 1,~\n$ Empates       <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,~\n$ Derrotas      <dbl> 0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 3, 0, 1, 1, 2, 1, 1,~\n$ `Gols Pro`    <dbl> 15, 18, 7, 7, 5, 5, 4, 3, 1, 1, 0, 0, 4, 12, 9, 11, 7, 4~\n$ `Gols Contra` <dbl> 3, 9, 6, 7, 3, 2, 3, 5, 3, 4, 4, 8, 13, 3, 6, 8, 7, 3, 4~\n$ Seleção       <chr> \"Uruguai\", \"Argentina\", \"Estados Unidos\", \"Sérvia\", \"Chi~\n\n\nQuem mais jogou?\n\ndf %>% group_by(Seleção) %>% \n  summarise(total_jogos = sum(as.numeric(NumJogos))) %>%\n  arrange(desc(total_jogos)) %>% \n  slice(1:5) %>% \n  ggplot(aes(x = Seleção, y= total_jogos,label =total_jogos)) +\n  geom_col(fill = \"#0b8d96\") +\n  geom_text(position = position_stack(vjust = 1.05),\n            color =\"#011112\")+\n  labs(title = \"Seleções que mais jogaram\",\n       subtitle = \"Dados agregados desde a copa de 1934\",\n       y = \"\",x =\"seleções\") +\n  theme(plot.title = element_text(face = \"bold\",size = 12),\n        plot.subtitle = element_text(face= \"italic\",size =10),\n        )\n\n\n\n\nDesempenho do Brasil.\n\ndf %>%filter(Seleção == \"Brasil\")%>% select(1:6) %>%   \n  tail() %>% \n  kable(caption = \"Desempenho do Brasil nas últimas copas\",\n        col.names = c(\"Ano\",\"Posição\",\"Número de Jogos\",\n                      \"Vitórias\",\"Empates\",\"Derrotas\"),\n        align = \"cccccc\")\n\n\nDesempenho do Brasil nas últimas copas\n\nAno\nPosição\nNúmero de Jogos\nVitórias\nEmpates\nDerrotas\n\n\n\n1998\n2\n7\n4\n1\n2\n\n\n2002\n1\n7\n7\n0\n0\n\n\n2006\n5\n5\n4\n0\n1\n\n\n2010\n6\n5\n3\n1\n1\n\n\n2014\n4\n7\n3\n2\n2\n\n\n2018\n6\n5\n3\n1\n1\n\n\n\n\n\nDesempenho das seleções campeãs de copa do mundo\n\ndf %<>% group_by(Seleção) %>% \n  mutate(campeao = if_else(Posição ==1,1,0),\n         Titulo_acumulado = purrr::accumulate(.x = campeao, \n                                    .f = ~ .x + .y))\n\n\ndf %>% filter(Titulo_acumulado !=0) %>% \n  ggplot(aes(Ano,Titulo_acumulado,color =Seleção))+\n  geom_bump(size =1.5) +\n  geom_point(size =3) +  \n  labs(title = \"Desempenho das Seleções\",\n       subtitle = \"1930-2018\",\n       x =\"Ano\",\n       y =\"Número de Títulos\") + \n  scale_x_continuous(breaks = seq(1930,2018,4)) +\n  theme(plot.title = element_text(face =\"bold\", size = 14),\n        plot.subtitle = element_text(face = \"italic\", size = 10,\n                        margin = margin(b = 0.5, unit = \"cm\")),\n        axis.text.y = element_text(face =\"bold\",size =10,\n                                    colour = \"#030202\"),\n        axis.text.x = element_text(face =\"bold\",size =10,\n                                    colour = \"#030202\",\n                                   angle = 90),\n        )\n\n\n\n\nTodas as seleções que venceram a copa do mundo fizeram mais gols?\n\nmaxGols <-df %>% group_by(Ano) %>% \n  summarise(nmaxgols = max(`Gols Pro`))\n\ncamp_edicao <- df %>% filter(Posição == 1)\n\nTexto <- paste(\n  strwrap(\"Número máximo de gols\",15),\n  collapse = \"\\n\")\n\n#Geralmente adoto um padrão os gráficos mas por algum motivo o ggplot não estava reconhecendo os nomes das colunas.\nggplot() +\n  geom_line(aes(x =maxGols$Ano,\n                y =maxGols$nmaxgols),\n            linetype = 1) +\n  scale_x_continuous(breaks = seq(1930,2018,4)) +\n  geom_point(aes(x=camp_edicao$Ano,\n                 y=camp_edicao$`Gols Pro`,\n                 color = camp_edicao$Seleção),\n             size = 2.1) +\n  scale_color_brewer(palette=\"Paired\") +\n  labs(title = \"Gols por Copa\",\n       subtitle = \"Seleções Campeãs de 1930 até 2018\",\n       x=\"Ano\",\n       y =\"Gols\",\n       color = \"Seleção Campeã\"\n       ) +\n   annotate(\"text\",x = 1938 ,y =23,size = 3,\n           label = Texto, fontface=\"bold\",colour=\"black\")+\n  theme(plot.title = element_text(face =\"bold\", size = 14),\n        plot.subtitle = element_text(face = \"italic\", size = 10,\n                        margin = margin(b = 0.5, unit = \"cm\")),\n        axis.text.y = element_text(face =\"bold\",size =10,\n                                    colour = \"#030202\"),\n        axis.text.x = element_text(angle = 90,\n                                   face =\"bold\",size =10,\n                                    colour = \"#030202\")) \n\n\n\n\nSinceramente eu não lembrava que a La Fúria (Seleção Espanhola) tinha marcado poucos gols em 2010 (Ano do Título), o time de Xavi e Iniesta era conhecido pela alta posse de bola e pela grande quantidade de passes, a Alemanha marcou o dobro de gols nesta edição."
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#tema",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#tema",
    "title": "Extraindo dados da wikipedia",
    "section": "Tema",
    "text": "Tema\nRecentemente houve a troca do primeiro ministro do Reino Unido a premiê Liz Truss, sendo destacada por ser a que ficou menos tempo no cargo, foi substituída por Rishi Sunak. Esse video da BBC conta um pouco de quem foi Liz Truss e como foi seu governo."
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#tratamento",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#tratamento",
    "title": "Extraindo dados da wikipedia",
    "section": "Tratamento",
    "text": "Tratamento\nNem sempre os dados estão estrurados do jeito que gostariámos (aliás quase nunca está). O Dataframe obtido está bagunçado então precisamos realizar uma “faxina”, padronizando as linhas e colunas.\n\n# |message: false\n# |warnings: false\ndados %>% head(3) %>% knitr::kable(caption = \"A Tabela Original\")\n\n\nA Tabela Original\n\n\n\n\n\n\n\n\n\n\n\n\n\nN.º\nPrimeiro-ministro (Nascimento–Falecimento)\nPrimeiro-ministro (Nascimento–Falecimento)\nMandato (Duração em anos e dias)\nMandato (Duração em anos e dias)\nPartido\nPartido\nCargos ministeriais ocupados como primeiro-ministro\nMonarca (Reino)\nRef.\n\n\n\n1\n\nSir Robert Walpole 1.º Conde de Orford (1676–1745)\n3 de abril de 1721 – 11 de fevereiro de 1742\n1722\n\nWhig\nChanceler do TesouroPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\nJorge I (1714–1727)\n[20]\n\n\n1\n\nSir Robert Walpole 1.º Conde de Orford (1676–1745)\n3 de abril de 1721 – 11 de fevereiro de 1742\n1727\n\nWhig\nChanceler do TesouroPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\nJorge II (1727–1760)\n[20]\n\n\n1\n\nSir Robert Walpole 1.º Conde de Orford (1676–1745)\n3 de abril de 1721 – 11 de fevereiro de 1742\n1734\n\nWhig\nChanceler do TesouroPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\nJorge II (1727–1760)\n[20]\n\n\n\n\n\nNão existe uma regra para realizar essa operação, a única certeza é que vai ser mais trabalhoso do que você pensou.\nO que me ajudou bastante foi desenhar e/ou imaginar a tabela final e fazer o simples mesmo que pareça preguiçoso, o importante é estar correto. Neste processo tem que ter paciência, pois uma operação equivocada (ou incompleta) pode ajudar a resolver um problema de um conjunto de linhas e simultaneamente prejudicar outro conjunto.\n\n\n\n\n\n\nAtenção ao volume de dados!\n\n\n\n\n\nSempre é importante verificar a tabela após cada operação, mas uma coisa é inspessionar um Dataframe de 100 linhas, é mais facíl monitorar os erros, outra é inspessionar um Dataframe de 50000 linhas. Então tenha cuidado e bom senso.\n\n\n\nO processo é literalmente um aprendizado, ao longo do caminho você já sabe o que precisa ser descartado (seja linhas ou colunas), as micro alterações (ajustes específicos), as macro alterações (as mais perigosas) e que operações cada coluna necessita. Esse processo te aproxima do resultado que você espera."
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#mão-na-massa",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#mão-na-massa",
    "title": "Extraindo dados da wikipedia",
    "section": "Mão na massa",
    "text": "Mão na massa\nExistem colunas com nomes idênticos mas informações diferentes.\n\n df <-dados %>% select(c(1,3,4,7,8)) %>% #selecionei as colunas de interesse \n rename(\n   c('ministro'='Primeiro-ministro (Nascimento–Falecimento)')'mandato'='Mandato (Duração em anos e dias)'as)',\n     'cargo' ='Cargos ministeriais ocupados como primeiro-ministro'))  %>%  #renomeando as colunas \n   filter(!grepl('dias',mandato)) %>% # eliminei as linhas que estão poluindo  \n   distinct() %>% # eliminei as linhas iguais\n   slice(-80) #eliminei a última linha manualmentee\n\nAgora quero colocar as datas em um formato em que o R interprete.\n\n#separando as colunas\ndf %<>% separate(mandato,\n                c(\"InicioMandato\",\"FimMandato\"),\n                sep =\"–\"“\",\n                convert = T,\n                remove = T,\n                )\n\n\n# | message: false\n# Separando as colunas para obter dia,mês e ano do início e fim de mandatoto\ndf %<>% separate(InicioMandato,\n                c(\"DiaIM\",\"MesIM\",\"AnoIM\"),\n                sep =\"de \",\n                remove = T)\ndf %<>% separate(FimMandato,\n                c(\"DiaFM\",\"MesFM\",\"AnoFM\"),\n                sep =\"de \",\n                remove = T)\n\nWarning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [79].\n\n\n\n# obtendo um valor numérico dos mesess\ndf %<>% mutate(MesIM = case_when(\n  MesIM == \"janeiro \" ~ 1,\n  MesIM == \"fevereiro \" ~ 2,\n  MesIM == \"março \"\"~~33,\n  MesIM == \"abril \" ~ 4,\n  MesIM == \"maio \" ~ 5,\n  MesIM == \"junho \" ~ 6,\n  MesIM == \"julho \" ~ 7,\n  MesIM == \"agosto \" ~ 8,\n  MesIM == \"setembro \" ~ 9,\n  MesIM == \"outubro \" ~ 10,\n  MesIM == \"novembro \" ~ 11,\n  MesIM == \"dezembro \" ~ 12\n),\n  MesFM = case_when(\n  MesFM == \"janeiro \" ~ 1,\n  MesFM == \"fevereiro \" ~ 2,\n  MesFM == \"março \"\"~~33,\n  MesFM == \"abril \" ~ 4,\n  MesFM == \"maio \" ~ 5,\n  MesFM == \"junho \" ~ 6,\n  MesFM == \"julho \" ~ 7,\n  MesFM == \"agosto \" ~ 8,\n  MesFM == \"setembro \" ~ 9,\n  MesFM == \"outubro \" ~ 10,\n  MesFM == \"novembro \" ~ 11,\n  MesFM == \"dezembro \" ~ 12))\n\nÉ necessário uniformizar os dados, pois o espacinho em branco atrapalha as operações\n\ndf$AnoIM <- df$AnoIM %>% str_replace_all(\" \",\"\")\ndf$AnoFM <- df$AnoFM %>% str_replace_all(\" \",\"\")\n\nAgora podemos unir as colunas criadas para formar a data completa.\n\n# União das colunas  \ndf %<>% unite(\"Data_Inicio_Mandato\",\n             c(\"AnoIM\",\"MesIM\",\"DiaIM\"),\n             sep = \"/\") \ndf %<>% unite(\"Data_Fim_Mandato\",\n             c(\"AnoFM\",\"MesFM\",\"DiaFM\"),\n             sep = \"/\") \n# convertendo para o formato de datas\ndf$Data_Inicio_Mandato %<>%  as.Date() # convertendo\ndf$Data_Fim_Mandato %<>%  as.Date()\n\ndf$Data_Fim_Mandato[is.na(df$Data_Fim_Mandato)] <- now() # como o ministro ainda está em exercício colocamos o dia atual como último dia. a. \n\nCom o novo formato podemos obter a duração dos mandatos.\n\ndf %<>% mutate(duracao = df$Data_Fim_Mandato - df$Data_Inicio_Mandato)\n\nAqui estão as alterações simples e preguiçosas. São modificações tão específicas que é mais viável fazer a alteração manual do que buscar um método mais elaborado.\n\nNeste caso eram erros de ortografia e referências.\n\n\ndf$ministro[df$ministro == \"Sir Robert Walpole 1.º Conde de Orford (1676–1745)\"])<- \"Sir Robert Walpole 1.º Conde de Oxford (1676–1745)\"1745)\"\n\ndf$ministro[df$ministro ==  \"William Pitt, o Velho 1.º Conde de Chatham[a](1708–1778)\"])<-\"William Pitt, o Velho 1.º Conde de Chatham (1708–1778)\"1778)\"\n\ndf$ministro[df$ministro ==  \"(1) William Pitt, o Novo[b](1759–1806)\"]\"<-\"(1) William Pitt, o Novo (1759–1806)\"06)\"\n\ndf$ministro[df$ministro ==  \"(2) Benjamin Disraeli 1.º Conde de Beaconsfield[c](1804–1881)\"])<-\"(2) Benjamin Disraeli 1.º Conde de Beaconsfield (1804–1881)\"1881)\"\n\ndf$ministro[df$ministro ==  \"Alec Douglas-Home Barão Home de Hirsel[d](1894–1986)\"])<-\"Alec Douglas-Home Barão Home de Hirsel (1894–1986)\"1986)\"\n\nAgora com a tabela uniformizada podemos extrair um conjunto de caracteres utilizando expressões regulares (Regex). Neste caso queremos identificar e remover o padrão “(Ano de Nascimento - Ano de Falecimento)”\n\ndf$ministro <- df$ministro %>% str_replace_all(\"[(][0-9]{4}[–][0-9]{4}[)]|[(][0-9]{4}[)]\",\"\")\n\nFinalmente temos a tabela tratada.\n\ndf %>% head() %>% knitr::kable(caption = \"Tabela Tratada\")\n\n\nTabela Tratada\n\n\n\n\n\n\n\n\n\n\nN.º\nministro\nData_Inicio_Mandato\nData_Fim_Mandato\nPartido\ncargo\nduracao\n\n\n\n1\nSir Robert Walpole 1.º Conde de Oxford\n1721-04-03\n1742-02-11\nWhig\nChanceler do TesouroPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\n7619 days\n\n\n2\nSpencer Compton 1.º Conde de Wilmington\n1742-02-16\n1743-07-02\nWhig\nPrimeiro Lorde do Tesouro\n501 days\n\n\n3\nHenry Pelham\n1743-08-27\n1754-03-06\nWhig\nChanceler do TesouroPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\n3844 days\n\n\n4\n(1) Thomas Pelham-Holles 1.º Duque de Newcastle\n1754-03-16\n1756-11-11\nWhig\nPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\n971 days\n\n\n5\nWilliam Cavendish 4.º Duque de Devonshire\n1756-11-16\n1757-06-29\nWhig\nPrimeiro Lorde do TesouroLíder da Câmara dos ComunsLorde Alto Tesoureiro da Irlanda\n225 days\n\n\n6\n(2) Thomas Pelham-Holles 1.º Duque de Newcastle\n1757-06-29\n1762-05-26\nWhig\nPrimeiro Lorde do TesouroLíder da Câmara dos Comuns\n1792 days"
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#ver-também",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#ver-também",
    "title": "Extraindo dados da wikipedia",
    "section": "Ver também",
    "text": "Ver também\n\nBeatriz Milz\nCurso R"
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#visualizações",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#visualizações",
    "title": "Extraindo dados da wikipedia",
    "section": "Visualizações",
    "text": "Visualizações\nQuem passou mais tempo no cargo?\n\n# |message: false\n# |warnings: false\n\ntexto <- paste(\n  strwrap(\"Os 5 Primeiros-Ministros que permaneceram por mais tempo no cargo\",\n          30),\n  collapse = \"\\n\")\n\n\ndf %>% arrange(desc(duracao)) %>% \n  slice(1:5) %>% \n  ggplot(\n    aes(x = duracao,\n        y =ministro,\n        label = duracao)) +\n  geom_col(fill =\"#3c43c7\", size=0.05) + \n  geom_text(position = position_stack(vjust =1.05),\n            color=\"#030202\") +\n  \n  labs(title = texto,\n       subtitle = \"Duração em dias.\".\",\n       caption = \"(n) = contagem do mandato\",\n       y = \"\",\n       x =\"\" ) +\n    theme(axis.text.x = element_blank(),\n          axis.ticks.x=element_blank(),\n          axis.text.y =element_text(face =\"bold\",\n                                    colour = \"#030202\"))\n\nDon't know how to automatically pick scale for object of type difftime. Defaulting to continuous.\nDon't know how to automatically pick scale for object of type difftime. Defaulting to continuous.\nDon't know how to automatically pick scale for object of type difftime. Defaulting to continuous.\n\n\n\n\n\nEm que mês costuma terminar os mandatos?\n\ndf %>% group_by(mes = month(Data_Fim_Mandato, label = TRUE)) %>%   summarise(contagem =n()) %>% \n  ggplot(aes(x =mes,y =contagem, label = contagem ))+\n  geom_col(fill =\"#e05c09\") +\n  geom_text(vjust = 1.25) +\n  labs(title = \"Quantidade de términos de mandatos em cada mês\"s\",\n       subtitle = \"Desde 1742.\", y =\"\",x=\"\") +\n  theme(axis.text.y = element_blank(),\n        axis.ticks.y= element_blank(),\n        axis.text.x = element_text(face =\"bold\",size =8,\n                                    colour = \"#030202\"),\n        plot.title = element_text(face =\"bold\", size = 14),\n        plot.subtitle = element_text(face = \"italic\", size = 10,\n                        margin = margin(b = 0.5, unit = \"cm\")))\n\n\n\n\nÚltimos ministros que passarem pelo cargo.\n\ndf%>% filter(Data_Inicio_Mandato > \"2000-01-01\") %>% \n  mutate(\n    mandato_or = fct_reorder(ministro,Data_Inicio_Mandato))%>% \n  ggplot((aes(x=Data_Inicio_Mandato,xend = Data_Fim_Mandato,y = mandato_or))) +\n  geom_dumbbell(size =2.5,color=\"#cbcbd6\",colour_x =\"#3eb2f0\",\n                colour_xend = \"#0909ab\",dot_guide=TRUE,\n                dot_guide_size=0.25) +\n  labs(x =\"Ano\",y = \"\",title = \"Últimos Ministros\"\",\n       subtitle = \"A partir dos anos 2000\") +\n  theme(plot.title = element_text(face =\"bold\", size = 14),\n        plot.subtitle = element_text(face = \"italic\", size = 10,\n                        margin = margin(b = 0.5, unit = \"cm\")),\n        axis.text.y = element_text(face =\"bold\",size =10,\n                                    colour = \"#030202\"))\n\n\n\n\nQual partido mais governou?\n\ndf  %>% group_by(Partido) %>% \n  summarise(Tempo = as.numeric(sum(duracao))) %>% \n  treemap(index = c(\"Tempo\",\"Partido\"),vSize = \"Tempo\",\n          align.labels=\n            list(c(\"center\", \"center\"),c(\"center\", \"top\")),\n          title = \"Tempo, em Dias, que Cada Partido Governou\",\n          fontsize.labels=c(12,10),\n          palette = \"BrBG\") \n\n\n\n\n\n\n\n\n\n\nCuriosidade!\n\n\n\n\n\nAlguns partidos foram dissolvidos ou fundidos a outros partidos como por exemplo:\n\nTory ⟹ Partido Conservador\nWing ⟹ Partido Liberal"
  },
  {
    "objectID": "posts/Governos do Reino Unido/Web Scraping.html#sugestão",
    "href": "posts/Governos do Reino Unido/Web Scraping.html#sugestão",
    "title": "Extraindo dados da wikipedia",
    "section": "Sugestão",
    "text": "Sugestão\nUma boa ideia é extrair os títulos reais da coluna de ministros para realizar análises. Uma coluna que acabou não sendo utilizada é a de cargo, os cargos são strings que estão “coladas” uma na outra o desafio é separa-las"
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html#os-dados",
    "href": "posts/Copa do Mundo/Copa do Mundo.html#os-dados",
    "title": "Usando R para acessar google sheet",
    "section": "Os Dados",
    "text": "Os Dados\nOlhando o youtube me deparei com um evento gratuito de ensino de Power Bi e Excel com tema copa do mundo nada mais justo do que dar os devidos créditos, Leonardo - Power Bi Experience.\nA planilha (xlsx) foi baixada e convertida para uma google sheet (Explicado nesse tópico: Manipulações). É um conjunto de dados sobre a copa do mundo que traz o desempenho das seleções em cada edição, os artilheiros e detalhes das finais."
  },
  {
    "objectID": "posts/Copa do Mundo/Copa do Mundo.html#ver-também",
    "href": "posts/Copa do Mundo/Copa do Mundo.html#ver-também",
    "title": "Usando R para acessar google sheet",
    "section": "Ver também",
    "text": "Ver também\n\nBeatriz Milz"
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html",
    "href": "posts/Big Mac/Big Mac.html",
    "title": "Poder de Compra e Big Mac",
    "section": "",
    "text": "A revista britânica The Economics em 1986 criou o índice Big Mac (ou Big Mac Index). Seu objetivo era comparar o poder de compra de cada país utilizando o preço de um big mac .\n\n\n\n\nO índice pode ser calculado pela seguinte fórmula:\n\\[\nÍndice\\,Big\\,Mac = \\frac{Preço\\, Big\\, Mac\\, no\\, país}{\nPreço\\, Big\\, Mac\\, no\\, EUA*taxa\\, de\\, câmbio }\\, -1\n\\]\nUm valor positivo significa que a moeda naquele momento está valorizada frente ao dólar americano, já um valor negativo indica que a moeda está subvalorizada. Os Estados Unidos da América recebe o valor de zero para seu índice, pois é a base de estudo.\n\n\n\n\n\n\nCuriosidade!!!\n\n\n\n\n\nNesse post a moeda estudada foi o Dólar Americano, entretanto já existe dados comparando as outras moedas como o Euro, Libra Esterlina, yuan chinês, e entre outras moedas.\n\n\n\nEsse índice permite também calcular a razão de troca ou paridade do poder de compra:\n\\[\nRazão\\,de\\,troca = \\frac{Preço\\,Big\\,Mac\\,no\\,país}{Preço\\,em\\, dolar}\n\\]\nGostaria de mostrar uma biblioteca que conheci recentemente ,(Arnold 2021), ela da uma embelezada no seus gráficos."
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html#bibliotecas",
    "href": "posts/Big Mac/Big Mac.html#bibliotecas",
    "title": "Poder de Compra e Big Mac",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr) # tratamento de dados\nlibrary(knitr) # formatação de tabela\nlibrary(ggplot2) # gráficos\nlibrary(ggthemes) # temas de gráficos\nlibrary(lubridate) # tratamento de datas\nlibrary(glue) # colar textos"
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html#carregando-os-dados",
    "href": "posts/Big Mac/Big Mac.html#carregando-os-dados",
    "title": "Poder de Compra e Big Mac",
    "section": "Carregando os dados",
    "text": "Carregando os dados\nOs dados podem ser encontrados no kaggle.\n\ndf <- read.csv(\"big_mac.csv\")\n\n\nglimpse(df)\n\nRows: 1,631\nColumns: 19\n$ date          <chr> \"2000-04-01\", \"2000-04-01\", \"2000-04-01\", \"2000-04-01\", …\n$ iso_a3        <chr> \"ARG\", \"AUS\", \"BRA\", \"CAN\", \"CHE\", \"CHL\", \"CHN\", \"CZE\", …\n$ currency_code <chr> \"ARS\", \"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CNY\", \"CZK\", …\n$ name          <chr> \"Argentina\", \"Australia\", \"Brazil\", \"Canada\", \"Switzerla…\n$ local_price   <dbl> 2.50, 2.59, 2.95, 2.85, 5.90, 1260.00, 9.90, 54.37, 24.7…\n$ dollar_ex     <dbl> 1.0000000, 1.6800000, 1.7900000, 1.4700000, 1.7000000, 5…\n$ dollar_price  <dbl> 2.500000, 1.541667, 1.648045, 1.938776, 3.470588, 2.4513…\n$ USD_raw       <dbl> 0.11607, -0.31176, -0.26427, -0.13448, 0.54937, 0.09436,…\n$ EUR_raw       <dbl> 0.05007, -0.35246, -0.30778, -0.18566, 0.45774, 0.02964,…\n$ GBP_raw       <dbl> -0.16722, -0.48645, -0.45102, -0.35417, 0.15609, -0.1834…\n$ JPY_raw       <dbl> -0.09864, -0.44416, -0.40581, -0.30099, 0.25130, -0.1161…\n$ CNY_raw       <dbl> 1.09091, 0.28939, 0.37836, 0.62152, 1.90267, 1.05023, 0.…\n$ GDP_bigmac    <dbl> 7803.329, 29144.877, 4822.739, 26087.329, 23872.716, 464…\n$ adj_price     <dbl> 1.922652, 2.301550, 1.869734, 2.247266, 2.207948, 1.8665…\n$ USD_adjusted  <dbl> 0.39117, -0.28335, -0.05696, -0.07698, 0.68172, 0.40514,…\n$ EUR_adjusted  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ GBP_adjusted  <dbl> -0.06626, -0.51898, -0.36704, -0.38047, 0.12876, -0.0568…\n$ JPY_adjusted  <dbl> 0.10096, -0.43285, -0.25369, -0.26953, 0.33090, 0.11201,…\n$ CNY_adjusted  <dbl> 0.97153, 0.01563, 0.33645, 0.30809, 1.38330, 0.99133, 0.…"
  },
  {
    "objectID": "posts/Eleição/eleicao_2022.html#bibliotecas",
    "href": "posts/Eleição/eleicao_2022.html#bibliotecas",
    "title": "Mapa Eleitoral",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\n#library(basedosdados)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(geobr)\n\n\ndf <- read.csv(\"dados.csv\")\n\ndados-tse-368314\nbasedosdados.br_tse_eleicoes.receitas_candidato\n# Defina o seu projeto no Google Cloud set_billing_id(“<YOUR_PROJECT_ID>”)"
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html#no-mundo",
    "href": "posts/Big Mac/Big Mac.html#no-mundo",
    "title": "Poder de Compra e Big Mac",
    "section": "No Mundo",
    "text": "No Mundo\nAtualmente que países possuim um índice positivo, ou seja, que possuim uma moeda valorizada em relação ao dólar americano?\n\ndf |> filter(USD_raw > 0, date %in% max(date)) |>\n  ggplot(aes(x =reorder(name,USD_raw),y = USD_raw)) + \n  geom_col(fill = \"#236fa8\") +\n  labs(title = \"Países com moeda valorizada\",\n       subtitle = \"índices positivos em relação ao dólar em 01/07/2022\",\n       x = \"\",\n       y = \"índice Big Mac\",\n       caption = \"Mendes, Jorge L.,2023\") +\n  theme(\n    plot.title = element_text(face = \"bold\",size = 14),\n    axis.text.x = element_text(angle = 45)\n    \n  )\n\n\n\n\nQuais países possuem o menor índice?\n\ndf |> filter( date %in% max(date)) |>\n  arrange(desc(-USD_raw)) |> head() |> \n  ggplot(aes(x =reorder(name,USD_raw),y = USD_raw)) + \n  geom_col(fill = \"#db6d1f\") +\n  labs(title = \"Países com moeda subvalorizada\",\n       subtitle = \"índices positivos em relação ao dólar em 01/07/2022\",\n       x = \"\",\n       y = \"índice Big Mac\",\n       caption = \"Mendes, Jorge L.,2023\") +\n  theme(\n    plot.title = element_text(face = \"bold\",\n                              size = 14),\n    axis.text.x = element_text(angle = 45)\n    \n  )+\n  theme_solarized(base_size = 15, light = FALSE)"
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html#situação-do-brasil.",
    "href": "posts/Big Mac/Big Mac.html#situação-do-brasil.",
    "title": "Poder de Compra e Big Mac",
    "section": "Situação do Brasil.",
    "text": "Situação do Brasil.\n\nBr <- df |>  filter(name == \"Brazil\")\n#últimas 5 linhas\nBr|> \n  tail() |>  \n  select(1,4:8) |> \n  knitr::kable(col.names = \n                 c(\"Data\",\"País\",\n                   \"Preço Local\",\"Razão de Troca\",\n                   \"Preço Dolar\",\"Índice(dólar)\"),\"pipe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nData\nPaís\nPreço Local\nRazão de Troca\nPreço Dolar\nÍndice(dólar)\n\n\n\n32\n2020-01-14\nBrazil\n19.9\n4.14190\n4.804558\n-0.00320\n\n\n33\n2020-07-01\nBrazil\n20.9\n5.34045\n3.913528\n-0.18806\n\n\n34\n2021-01-01\nBrazil\n21.9\n5.50460\n3.978491\n-0.18640\n\n\n35\n2021-07-01\nBrazil\n22.9\n5.24865\n4.363027\n-0.11500\n\n\n36\n2022-01-01\nBrazil\n22.9\n5.31000\n4.312618\n-0.14432\n\n\n37\n2022-07-01\nBrazil\n22.9\n5.39175\n4.247230\n-0.17530\n\n\n\n\n\n\n#convertendo a coluna para data\nBr$date <- lubridate::as_date(Br$date)\n\nPodemos analisar a evolução temporal do preço.\n\nGrafico_base <- Br |> ggplot() +\n  geom_line(aes(x=date,y =local_price),\n            linewidth = 1.2,\n            color =\"#d10404\" ) +\n  \n  geom_line(aes(x=date,y = mean(local_price)),\n          linetype =2,\n          color ='#5c5a5a') +\n  geom_point(aes(x=max(date),y = max(local_price)),\n             color ='#d10404',\n             size = 3) \n\nMax_price <- Br |>  filter(date %in% max(date)) |> \n  mutate(label = glue::glue(\"R$ {round(local_price,2)}\"))\n\n\nGrafico_base +\n  \n  labs(y = 'Real',\n       x ='Ano',\n       title = \"Preço do Big Mac no Brasil\",\n       subtitle = \"2000-2022\",\n       caption = \"Mendes, Jorge L.,2023 \") +\n  \n  annotate('text',\n           x=min(Br$date),\n           y =13.2,\n           label = \"Média\",\n          colour = \"#5c5a5a\",\n          size = 3,\n          fontface = 'bold') +\n  \n  ggrepel::geom_text_repel(\n    data = Max_price,\n    aes(x = date,y = local_price,label = label),\n    size = 5,\n    color = \"#d10404\",\n    nudge_y = -5,\n    nudge_x = 0,\n    min.segment.length = 0) +\n  \n  \n  theme(\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_blank(),\n    plot.title = element_text(face = \"bold\",size = 14)) +\n  theme_economist()\n\n\n\n\nPodemos analizar o comportamento da razão de troca ao longo tempo.\n\nBr |> \n  ggplot(aes(x = date,y =dollar_ex)) + \n  geom_line(color = \"#218572\", linetype = 2, linewidth = 0.8) +\n  labs(title =\"Razão de troca\",\n       subtitle = \"Real Brasileiro/Dólar Americano 2000-2022\",\n       caption = \"Mendes, Jorge L,2023\",\n       x = \"Data\",\n       y = \"R$/$\") +\n  theme(\n    plot.title = element_text(face = \"bold\",size =14) \n  ) +\n  theme_economist_white()"
  },
  {
    "objectID": "posts/Big Mac/Big Mac.html#ver-também",
    "href": "posts/Big Mac/Big Mac.html#ver-também",
    "title": "Poder de Compra e Big Mac",
    "section": "Ver também",
    "text": "Ver também\n\nCurso R\nDicionário Financeiro\nTemas\nGGplot"
  },
  {
    "objectID": "posts/Otimização/Otimização.html",
    "href": "posts/Otimização/Otimização.html",
    "title": "Otimização",
    "section": "",
    "text": "Na engenharia obtemos várias soluções para um determinado problemas. O desafio é encontrar uma solução ótima considerando todas as restrições. Tudo depende do objetivo almejado, seja maximizando o lucro ou minimizando o custo de uma operação por exemplo.\n\nfonte: https://atemporaledesign.com.br\nO lpSolve é um software gratuito para resolução de programação linear, Linear/inteira e entre outras que possui funções disponibilizadas para linguagem R.\n\n\n\n\n\n\nProgramação\n\n\n\n\n\nNa área de otimização Programação se relaciona com o tipo de problema a ser resolvido. Ela é do tipo linear quando a função a ser otimizada e suas restrições são lineares. Já a Linear inteira é quando algumas ou todas as variáveis são inteiras.\nExistem também problemas de designação que lida com transporte.\n\n\n\nDocumentação"
  },
  {
    "objectID": "posts/Otimização/Otimização.html#problema",
    "href": "posts/Otimização/Otimização.html#problema",
    "title": "Otimização",
    "section": "Problema",
    "text": "Problema\nExemplo 15.1 do Chapra1.\n\n\n\n\nVariáveis:\n\\[\nx_1 \\Rightarrow Regular\n\\] \\[\nx_2 \\Rightarrow Premium\n\\]\nFunção objetivo:\n\\[\nMaximize\\, Z= 150  x_1 +\\, 175x_2\n\\]\nRestrições:\n\\[\n7x_1\\,+11x_2\\, \\leq 77\\,\\,\\,\\,(restrição\\,\\,de\\,\\,material)\n\\]\n\\[\n10x_1 \\,+8x_2\\,\\leq 80\\,\\,\\,\\,\\,(restrição\\,\\,de\\,\\,tempo)\n\\]\n\\[\nx_1 \\,\\leq 9\\,\\,\\,\\,\\,(restrição\\,\\,de\\,\\,armazenamento\\,\\,do\\,\\,tipo\\,\\,\"\nregular\")\n\\]\n\\[\nx_2 \\,\\leq 6\\,\\,\\,\\,\\,(restrição\\,\\,de\\,\\,armazenamento\\,\\,do\\,\\,tipo\\,\\,\"premium\")\n\\]\n\\[\nx_1,x_2\\, \\geq 0\\,\\,\\,\\,\\,(restrição\\,\\,de\\,\\,sinal)\n\\]"
  },
  {
    "objectID": "posts/Otimização/Otimização.html#formulação-do-problema",
    "href": "posts/Otimização/Otimização.html#formulação-do-problema",
    "title": "Otimização",
    "section": "Formulação do problema",
    "text": "Formulação do problema\nPara resolução do problema será utilizado a estrura de matrizes com os coeficientes das equações.\n\nf.obj <- c(150,175) # Coeficientes da função objetiva\n\nf.con <- matrix(\n  c(7,11,\n    10,8,\n    1,0,\n    0,1,\n    1,0,\n    0,1),\n  nrow=6, byrow=TRUE) # Coeficientes das equações de restrições\n\nf.dir <- c(\"<=\",\"<=\",\"<=\",\"<=\",\">=\",\">=\") #Direção das equações de restrições\nf.rhs <- c(77,80,9,6,0,0) # Valores das restrições\n\nmodelo <- lp(\"max\", f.obj, f.con, f.dir, f.rhs) \n\nDetalhes do problema:\n\npaste(\"Funão objetiva =\", modelo$objective[1],\"x1 +\",modelo$objective[2],\"x2\")\n\n[1] \"Funão objetiva = 150 x1 + 175 x2\"\n\n\nPodemos verificar o status do modelo.\n\nif (modelo$status == 0) {\n  paste(\"Foi encontrada uma solução viável\")\n}else{\n  paste(\"Não foi encontrada uma solução viável\") \n}\n\n[1] \"Foi encontrada uma solução viável\"\n\n\nA resposta é um valor numérico sendo 0 indica que foi encontrada uma solução viável e 2 indica que não foi encontrada uma solução viável.\nVerificar o objetivo da otimização:\n\nif (modelo$direction == 1) {\n  paste(\"maximizar a função\")\n}else{\n  paste(\"minimizar a função\")\n}\n\n[1] \"maximizar a função\"\n\n\nO valor da função maximizada:\n\npaste(\"O lucro máximo é \",round(modelo$objval,2),\"/semana\")\n\n[1] \"O lucro máximo é  1413.89 /semana\"\n\n\nA solução otimizada:\n\npaste(\"Gás Regular:\",round(modelo$solution[1],2),\"ton/semana\")\n\n[1] \"Gás Regular: 4.89 ton/semana\"\n\npaste(\"Gás Premium:\",round(modelo$solution[2],2),\"ton/semana\") \n\n[1] \"Gás Premium: 3.89 ton/semana\""
  },
  {
    "objectID": "posts/Otimização/Otimização.html#ver-também",
    "href": "posts/Otimização/Otimização.html#ver-também",
    "title": "Otimização",
    "section": "Ver também",
    "text": "Ver também\n\nSupply Chain Data Analytics"
  },
  {
    "objectID": "posts/Otimização/Otimização.html#bibliotecas",
    "href": "posts/Otimização/Otimização.html#bibliotecas",
    "title": "Otimização",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(lpSolve)"
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html",
    "title": "Utilizando R para Modelagem",
    "section": "",
    "text": "Atualizado em 15/11/2023"
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#bibliotecas",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#bibliotecas",
    "title": "Utilizando R para Modelagem",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(deSolve)#pacote de resolução de EDO's\nlibrary(ggplot2)#gráficos"
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#ver-também",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#ver-também",
    "title": "Utilizando R para Modelagem",
    "section": "Ver Também",
    "text": "Ver Também"
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#problemas",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#problemas",
    "title": "Utilizando R para Modelagem",
    "section": "Problemas",
    "text": "Problemas\nTanque de Mistura\nImagine que temos um tanque onde água e sal são misturado perfeitamente. Nele ocorre uma entrada e uma saída de material e gostariamos de analisar como a massa de sal se comporta ao longo do tempo.\n\n\nFonte: Zill (Modificado)1\n\nPartindo da equação de balanço de massa podemos equacionar da seguinte forma:\n\\[\nE - S -r_j = A_c\n\\]\nNosso problema não envolve reação química. Podemos escrever a equação na forma de taxa de vazão mássica. A taxa de acúmulo descreve se ocorre alguma variação de algum parâmetro ao longo do tempo e quanto é essa variação.\n\\[\n\\frac{dm}{dt} =  M_{entrada} - M_{saída}\n\\]\n\\[\n\\frac{dm}{dt} = 0 ,\\  o \\ regime\\ é\\ estacionário, \\ se \\ não, \\ é\\ transiente   \n\\]\nlembrando que a vazão mássica pode ser escrita em termos da vazão volumétrica e a concentração da massa:\n\\[\nM = Q.C\n\\]\n\\[\nC = \\frac{m}{Vol}\n\\]\nConstrução do modelo.\n\nTanque_Mistura_1 &lt;- function(Time,State,Parametros){\n  with(as.list(c(State,Parametros)),{\n    \n    Entrada &lt;- Qin*d\n    Saida &lt;- (Ma*Qout)/V\n    dm = Entrada - Saida\n    return(list(c(dm)))\n  })\n  \n}\n\nAgora podemos espeficar os parâmetros\n\nparametros &lt;- c(Qin &lt;- 25, #taxa de entrada L/min\n                d &lt;- 0, #concentração de sal na entrada kg/L\n                Qout&lt;- 25, #taxa de saída   L/min\n                V &lt;- 1000) #volume do tanque em L\nyinicial &lt;- c(Ma =20) # condição inicial em kg\ntimes &lt;-seq(0,600) # min\nResultado &lt;-ode(yinicial,times,Tanque_Mistura_1,parametros,method =\"bdf\")\n\nA descrição visual do problema:\n\ntexto &lt;- paste(strwrap(\"Atingiu o estado estacionário\",10),collapse = '\\n')\nggplot() + \n  aes(x = Resultado[,\"time\"],y = Resultado[,\"Ma\"]) +\n  geom_line(color = \"#209799\") +\n  labs(y = \"Massa de Sal(Kg)\", x = \"Tempo(Min)\",title = \"Tanque de Mistura\",\n       subtitle = \"Tanque Único\", caption = \"Mendes,Jorge L\") +\n  annotate(\"text\",y = 4,x =500,label = texto, colour = \"#209799\",\n           size = 4) +\n  \n  theme(plot.title = element_text(face = \"bold\"),\n        plot.subtitle = element_text(family = \"italic\")) \n\n\n\n\nO modelo se comportou como esperado. A vazão de entrada era só de água pura, ou seja, quantidade de sal era nula, logo a quantidade de sal no tanque tende a diminuir com o passar do tempo até atingir o regime estacionário.\nNesse segundo exemplo há um sistema com dois tanques com um refluxo.\n\n\nFonte: Zill (Modificado)2\n\n\nTanque_Mistura_2 &lt;- function(Time,State,Parametros){\n  with(as.list(c(State,Parametros)),{\n    \n    dma &lt;- F1*d -(Ma*F2)/V +(Mb*F3)/V\n    dmb &lt;- (Ma*F3)/V - (Mb*F3)/V - (Mb*F4)/V\n    return(list(c(dma,dmb)))\n  })\n  \n}\n\nAgora podemos espeficar os parâmetros:\n\nparametros &lt;- c(F1 &lt;- 3, #alimentação do tanque A (puro) L/min\n                F2 &lt;- 4, #alimentação do tanque B (saída do tanque A) L/min\n                F3 &lt;- 1, #alimentação do tanque A (sáida do tanque B) L/min\n                F4 &lt;- 3, #Saída do tanque B  L/min\n                d &lt;- 0., #concentração de sal na entrada kg/L\n               \n                V &lt;- 1000) #volume do tanque em L\n\nyinicial &lt;- c(Ma =25,Mb = 0) # condição inicial massa em kg\n\ntimes &lt;-seq(0,1000) # intervalo de tempo em min\n\nResultado &lt;-ode(yinicial,times,Tanque_Mistura_2,parametros,method =\"bdf\")\n\nA descrição visual do problema:\n\ntexto &lt;- paste(strwrap(\"Atingiu o estado estacionário\",10),collapse = '\\n')\n\nggplot() + \n  geom_line(aes(x = Resultado[,\"time\"],y = Resultado[,\"Ma\"],\n                color = \"Tanque A\")) +\n  geom_line(aes(x = Resultado[,\"time\"],y = Resultado[,\"Mb\"],\n                color = \"Tanque B\")) +\n  labs(y = \"Massa de Sal(Kg)\", x = \"Tempo(Min)\",title = \"Tanque de Mistura\",\n       subtitle = \"Sistema de dois tanques\", caption = \"Mendes,Jorge L\",\n       color = \"Tanque\") +\n  scale_color_brewer(palette = \"Dark2\") +\n  annotate(\"text\",y = 5,x =900,label = texto, colour = \"#141313\",\n           size = 4,face =\"bold\") +\n  \n  theme(plot.title = element_text(face = \"bold\"),\n        plot.subtitle = element_text(family = \"italic\")) \n\n\n\n\nNote que houve um breve aumento de sal no tanque B, pois a alimentação do tanque do B tem uma quantidade de sal diferente da alimentação do tanque A que possui uma concentração nula."
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#extra",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#extra",
    "title": "Utilizando R para Modelagem",
    "section": "Extra",
    "text": "Extra\nO deSolve oferece diversos métodos para resolução de EDO’s como o BDF, Runge-Kutta, adams e etc. Para aqueles que tenham interesse em resolver na mão chegando na equação uma das minhas abordagens favoritas para resolução de EDO é a transformada de laplace. Basta ter uma tabela das transformadas de laplace tornando a resolução mais fácil que o convencional.\n\\[\nℒ\\left(\\{f(t)\\}\\right) = F(S)\n\\]\nPodemos fazer uma visualização do processo utilizando uma representação por blocos com o mermaid que é uma ferramenta do quarto.\n\n\n\n\n\nsequenceDiagram\n  participant EDO com condição inicial\n  participant Problema Algébrico\n  participant Solução Algébrica\n  participant Solução da EDO\n  EDO com condição inicial->> Problema Algébrico: Transformada de Laplace\n  Problema Algébrico->>Solução Algébrica: mais fácil\n  Solução Algébrica->>Solução da EDO: Transformada Inversa\n  EDO com condição inicial->> Solução da EDO: mais difícil"
  },
  {
    "objectID": "posts/Xgboost/xgboost.html",
    "href": "posts/Xgboost/xgboost.html",
    "title": "Como utilizar o xgboost no R",
    "section": "",
    "text": "O XGBoost (Extreme Gradient Boosting)(Chen et al. 2023) é uma biblioteca de código aberto que fornece um algoritmo de aprendizado de máquina de aumento de gradiente para tarefas de classificação, regressão e outros tipos de previsão. Ele se baseia na técnica de ensemble learning, que combina vários modelos de aprendizado de máquina mais simples para criar um modelo mais poderoso.\n\n\nFonte: https://siliconvalley.basisindependent.com/\n\nO XGBoost usa uma estratégia de aumento de gradiente para construir um modelo preditivo de forma iterativa, em que cada novo modelo é treinado para corrigir os erros cometidos pelos modelos anteriores. O algoritmo utiliza árvores de decisão como modelo base, que são combinadas usando um algoritmo de aumento de gradiente para produzir um modelo mais preciso e robusto."
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#introdução",
    "href": "posts/Xgboost/xgboost.html#introdução",
    "title": "Como utilizar o xgboost no R",
    "section": "",
    "text": "O XGBoost (Extreme Gradient Boosting)(Chen et al. 2023) é uma biblioteca de código aberto que fornece um algoritmo de aprendizado de máquina de aumento de gradiente para tarefas de classificação, regressão e outros tipos de previsão. Ele se baseia na técnica de ensemble learning, que combina vários modelos de aprendizado de máquina mais simples para criar um modelo mais poderoso.\n\n\nFonte: https://siliconvalley.basisindependent.com/\n\nO XGBoost usa uma estratégia de aumento de gradiente para construir um modelo preditivo de forma iterativa, em que cada novo modelo é treinado para corrigir os erros cometidos pelos modelos anteriores. O algoritmo utiliza árvores de decisão como modelo base, que são combinadas usando um algoritmo de aumento de gradiente para produzir um modelo mais preciso e robusto."
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#bibliotecas",
    "href": "posts/Xgboost/xgboost.html#bibliotecas",
    "title": "Como utilizar o xgboost no R",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr) #tratamento de dados\nlibrary(knitr) #tabelas\nlibrary(xgboost) \nlibrary(caret)\nlibrary(ggplot2) #gráficos"
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#carregando-os-dados",
    "href": "posts/Xgboost/xgboost.html#carregando-os-dados",
    "title": "Como utilizar o xgboost no R",
    "section": "Carregando os dados",
    "text": "Carregando os dados\nOs dados podem ser encontrados no kaggle.\n\ndf &lt;- read.csv(\"GermanCredit.csv\")\ndf &lt;- df |&gt; select(2:11)\ndf[df==\"\"] &lt;- NA\ndf |&gt; head() |&gt; \n  knitr::kable(col.names = c(\"Age\",\"Sex\",\"Job\",\"Housing\",\"Saving.accounts\",\n                             \"Checking.account\",\"Credit.amount\",\"Duration\",\n                             \"Purpose\",\"Risk\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAge\nSex\nJob\nHousing\nSaving.accounts\nChecking.account\nCredit.amount\nDuration\nPurpose\nRisk\n\n\n\n67\nmale\n2\nown\nNA\nlittle\n1169\n6\nradio/TV\ngood\n\n\n22\nfemale\n2\nown\nlittle\nmoderate\n5951\n48\nradio/TV\nbad\n\n\n49\nmale\n1\nown\nlittle\nNA\n2096\n12\neducation\ngood\n\n\n45\nmale\n2\nfree\nlittle\nlittle\n7882\n42\nfurniture/equipment\ngood\n\n\n53\nmale\n2\nfree\nlittle\nlittle\n4870\n24\ncar\nbad\n\n\n35\nmale\n1\nfree\nNA\nNA\n9055\n36\neducation\ngood\n\n\n\n\n\nPodemos ver o tipo de dado que estamos analisando:\n\nglimpse(df)\n\nRows: 1,000\nColumns: 10\n$ Age              &lt;int&gt; 67, 22, 49, 45, 53, 35, 53, 35, 61, 28, 25, 24, 22, 6…\n$ Sex              &lt;chr&gt; \"male\", \"female\", \"male\", \"male\", \"male\", \"male\", \"ma…\n$ Job              &lt;int&gt; 2, 2, 1, 2, 2, 1, 2, 3, 1, 3, 2, 2, 2, 1, 2, 1, 2, 2,…\n$ Housing          &lt;chr&gt; \"own\", \"own\", \"own\", \"free\", \"free\", \"free\", \"own\", \"…\n$ Saving.accounts  &lt;chr&gt; NA, \"little\", \"little\", \"little\", \"little\", NA, \"quit…\n$ Checking.account &lt;chr&gt; \"little\", \"moderate\", NA, \"little\", \"little\", NA, NA,…\n$ Credit.amount    &lt;int&gt; 1169, 5951, 2096, 7882, 4870, 9055, 2835, 6948, 3059,…\n$ Duration         &lt;int&gt; 6, 48, 12, 42, 24, 36, 24, 36, 12, 30, 12, 48, 12, 24…\n$ Purpose          &lt;chr&gt; \"radio/TV\", \"radio/TV\", \"education\", \"furniture/equip…\n$ Risk             &lt;chr&gt; \"good\", \"bad\", \"good\", \"good\", \"bad\", \"good\", \"good\",…\n\n\nPodemos ver algumas estatísticas dos dados:\n\nsummary(df)\n\n      Age            Sex                 Job          Housing         \n Min.   :19.00   Length:1000        Min.   :0.000   Length:1000       \n 1st Qu.:27.00   Class :character   1st Qu.:2.000   Class :character  \n Median :33.00   Mode  :character   Median :2.000   Mode  :character  \n Mean   :35.55                      Mean   :1.904                     \n 3rd Qu.:42.00                      3rd Qu.:2.000                     \n Max.   :75.00                      Max.   :3.000                     \n Saving.accounts    Checking.account   Credit.amount      Duration   \n Length:1000        Length:1000        Min.   :  250   Min.   : 4.0  \n Class :character   Class :character   1st Qu.: 1366   1st Qu.:12.0  \n Mode  :character   Mode  :character   Median : 2320   Median :18.0  \n                                       Mean   : 3271   Mean   :20.9  \n                                       3rd Qu.: 3972   3rd Qu.:24.0  \n                                       Max.   :18424   Max.   :72.0  \n   Purpose              Risk          \n Length:1000        Length:1000       \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n                                      \n                                      \n                                      \n\n\nPodemos ver quantidade de linhas vazias em cada coluna:\n\nfor (i in colnames(df)){\n  v &lt;- df[,i] |&gt; is.na() |&gt; sum()\n  print(paste(\"coluna:\",i,\"|Número de linhas vazias:\",v))\n}\n\n[1] \"coluna: Age |Número de linhas vazias: 0\"\n[1] \"coluna: Sex |Número de linhas vazias: 0\"\n[1] \"coluna: Job |Número de linhas vazias: 0\"\n[1] \"coluna: Housing |Número de linhas vazias: 0\"\n[1] \"coluna: Saving.accounts |Número de linhas vazias: 183\"\n[1] \"coluna: Checking.account |Número de linhas vazias: 394\"\n[1] \"coluna: Credit.amount |Número de linhas vazias: 0\"\n[1] \"coluna: Duration |Número de linhas vazias: 0\"\n[1] \"coluna: Purpose |Número de linhas vazias: 0\"\n[1] \"coluna: Risk |Número de linhas vazias: 0\""
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#análise-exploratória",
    "href": "posts/Xgboost/xgboost.html#análise-exploratória",
    "title": "Como utilizar o xgboost no R",
    "section": "Análise Exploratória",
    "text": "Análise Exploratória\nPodemos ver a proporção de homens e mulheres.\n\ndata_s &lt;-df |&gt; group_by(Sex) |&gt;  \n   summarise(count = n())  \npie(data_s$count,labels = data_s$Sex,\nmain = \"Proporção de homens e mulheres\")\n\n\n\n\nA distribuição de idade:\n\ndf |&gt; select(Age)|&gt; ggplot(aes(x =Age)) +\n  geom_histogram(fill =\"#454df8\",bins = 30) +\n  labs(title = \"Distribuição de Idades\", y =\"\",x =\"Idades\",\n       caption = \"Mendes, Jorge L.,2023\")+\n  theme(plot.title = element_text(face = \"bold\",size = 14),\n        axis.text.x = element_text(face = \"bold\",colour = \"#030202\",size =10),\n        axis.text.y = element_text(face = \"bold\",colour = \"#030202\",size =10))\n\n\n\n\nPodemos analisar a relação entre idade e quantia de crédito:\n\ndf |&gt; ggplot() +\n  geom_point(aes(x = Age, y = Credit.amount,color = Risk)) +\n  scale_color_manual(values =  c(\"#ed6002\",\"#02db47\")) +\n  labs(title = \"Relação entre crédito e idade\",\n       y = \"Quantidade de Crédito\", x= \"Idade\",\n       caption = \"Mendes, Jorge L.,2023\") +\n  theme(plot.title = element_text(face = \"bold\",colour = \"#030202\",size =15))"
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#modelagem",
    "href": "posts/Xgboost/xgboost.html#modelagem",
    "title": "Como utilizar o xgboost no R",
    "section": "Modelagem",
    "text": "Modelagem\nTransformação\nPrimeiro devemos transformar os dados categóricos em binários (0 e 1).\n\ndf &lt;- df |&gt; mutate(SexBi =case_when(\n  Sex ==\"male\"~ 0\n  ,Sex == \"female\"~ 1\n),\nRiskBi= case_when(Risk ==\"bad\"~0,\n                  Risk ==\"good\"~1))\n\n\n\n\n\n\n\nBinário\n\n\n\n\n\nSe as variáveis forem binárias como bem e mal, arriscado e seguro, e etc basta fazer como foi mostrado no tópico Transformação. Caso tenha mais parâmetros (por exemplo fácil,moderado e difícil) é necesário criar novas colunas que serão chamadas de variáveis dummies preenche-las com 0 e 1 conforme a ausência ou presença.\n\n\n\nSeleção\nPara abastecer o modelo é necessário definir quais serão as variáveis de entrada e de saída. Para nosso problema queremos criar um modelo que classifique o risco do empréstimo com base na idade, sexo, crédito e duração. E pela quantidade de dados podemos separar um conjunto de treino e um conjunto de teste de forma aleatória para podermos avaliar o modelo.\n\nset.seed(123)\n\nindice_treino &lt;- sample(1:nrow(df),0.7*nrow(df),replace = FALSE)\n\n\ndf_train &lt;-df[indice_treino,]\ndf_test &lt;-df[-indice_treino,]\n\nX_train &lt;- df_train |&gt; select(Age,Credit.amount,SexBi,Duration)\ny_train &lt;- df_train |&gt; select(RiskBi)\n\nX_test &lt;- df_test |&gt; select(Age,Credit.amount,SexBi,Duration)\ny_test &lt;- df_test |&gt; select(RiskBi)\n\n\n\n\n\n\n\nSeleção\n\n\n\n\n\nOs dados a serem selecionados podem ser determinados com análises estatísticas mais profundas como correlações e pca, e também vai depender da natureza do problema e do custo computacional envolvido.\nÉ possível fazer uma limpeza dos dados, ou seja, descartar linhas que podem atrapalhar o desempenho do modelo, preecher linhas que possuem dados ausentes, remover outliers, e etc.\n\n\n\nModelo\nCom os dados separados podemos escolher os parâmetros do modelo para treina-lo. Podemos definir o algoritmo, a profundidade da árvore, o número de iterações e entre outros parâmetros.\n\nparametros &lt;- list(objective = \"binary:logistic\", \n                    eval_metric = \"error\"\n                   )\nmodelo &lt;- xgboost(data = as.matrix(X_train),\n                  label = as.matrix(y_train),\n                  nrounds = 1,\n                  eta =0.1,\n                  params = parametros)\n\n[1] train-error:0.228571 \n\n\nAqui podemos ver como fica a visualzação de apenas um árvore.\n\nxgb.plot.tree(model = modelo, fsize = 8, margin = 30, \n              ylim = c(0, 0.2), xlimits = c(0, 1),\n              show_info = TRUE, dpi = 150)\n\n\n\n\n\nPredição\n\nparametros &lt;- list(objective = \"binary:logistic\", \n                    eval_metric = \"error\"\n                   )\nmodelo &lt;- xgboost(data = as.matrix(X_train),\n                  label = as.matrix(y_train),\n                  nrounds = 100,\n                  eta =0.1,\n                  params = parametros)"
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#ver-também",
    "href": "posts/Xgboost/xgboost.html#ver-também",
    "title": "Como utilizar o xgboost no R",
    "section": "Ver também",
    "text": "Ver também\n\nSigmoidal\nYukio Andre"
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#resultados",
    "href": "posts/Xgboost/xgboost.html#resultados",
    "title": "Como utilizar o xgboost no R",
    "section": "Resultados",
    "text": "Resultados\n\nR1 &lt;- predict(modelo,newdata = data.matrix(X_test)) |&gt;  \n  as_tibble() |&gt; \n  mutate(R = if_else(value &gt;= 0.5,1,0))\nR1 |&gt; head() |&gt; \n  knitr::kable(col.names = c(\"values\",\"R\"),align =\"l\")\n\n\n\nvalues\nR\n\n\n\n0.9893589\n1\n\n\n0.8878149\n1\n\n\n0.9059939\n1\n\n\n0.4113036\n0\n\n\n0.5090782\n1\n\n\n0.0504705\n0\n\n\n\n\n\nAcurácia do modelo.\n\nAc &lt;- mean(R1$R == y_test$RiskBi)*100\npaste(\"A acurácia é de\",Ac,\"%\")\n\n[1] \"A acurácia é de 68 %\""
  },
  {
    "objectID": "posts/Xgboost/xgboost.html#conclusão",
    "href": "posts/Xgboost/xgboost.html#conclusão",
    "title": "Como utilizar o xgboost no R",
    "section": "Conclusão",
    "text": "Conclusão\nEsse post é uma apresentação bem resumida sobre o tema de aprendizado de máquina. Existem difentes formas de se construir e avaliar um modelo de predição. Podemos melhorar a seleção de dados, a construção do modelo e escolher métricas mais adequadas , tudo isso vai depender da natureza do problema."
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#introdução",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#introdução",
    "title": "Utilizando R para Modelagem",
    "section": "Introdução",
    "text": "Introdução\nNa ciência sempre seguimos o roteiro observar o fenômeno, teorizar sobre ocorrido, propor um modelo físico e testar a hipótese. Minha parte favorita é a área da modelagem, nela conseguimos estruturar o problema a ser resolvido dando para outros campos como a simulação e a otimização.\nNa engenharia química (e nas outras engenharias) temos que lidar com balanços para modelar diversos processos. Primeiro definimos o volume de controle que basicamente é nossa região de interesse de estudo, analisamos os equipamentos envolvidos e o que acontece na fronteira do volume do controle (taxas de material e/ou de energia que entrem ou que saiem).\nEm problemas numéricos temos que lidar com o custo computacional, ou seja, o tempo processamento do modelo. Quanto mais simplificado o modelo menor será o custo computacional, logo você deve ter sabedoria na escolha do modelo, nos algoritmos de resolução e da precisão necessária. A biblioteca deSolve(Soetaert, Petzoldt, and Setzer 2010) é uma ferramenta muito interessante para resolver as EDO’s, EAD’s e EDA.\n\n\nDestilação Binária\n\nO destilador binário é um ótimo exemplo por que podemos analisar de muitas formas cada região/equipamento obtendo uma quantidade de equações que descrevem melhor o processo."
  },
  {
    "objectID": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#footnotes",
    "href": "posts/Equações Diferenciais Ordinárias/R para Modelagem.html#footnotes",
    "title": "Utilizando R para Modelagem",
    "section": "Footnotes",
    "text": "Footnotes\n\nZILL, Dennis G. Equações diferenciais com aplicações em modelagem. 3. São Paulo Cengage Learning 2016 1 recurso online ISBN 9788522124022.↩︎\n\n\n\n\nZILL, Dennis G. Equações diferenciais com aplicações em modelagem. 3. São Paulo Cengage Learning 2016 1 recurso online ISBN 9788522124022.\n\n\n↩︎"
  },
  {
    "objectID": "posts/Base dos Dados/Base dos Dados.html",
    "href": "posts/Base dos Dados/Base dos Dados.html",
    "title": "Base dos Dados",
    "section": "",
    "text": "A organização Base dos Dados fornece uma fonte riquissima dados públicos podendo ser acessados via python, R, SQL e Stata. Eles fornecessem tabelas tratadas de diferentes assuntos de forma gratuita e paga."
  },
  {
    "objectID": "posts/Base dos Dados/Base dos Dados.html#introdução",
    "href": "posts/Base dos Dados/Base dos Dados.html#introdução",
    "title": "Base dos Dados",
    "section": "",
    "text": "A organização Base dos Dados fornece uma fonte riquissima dados públicos podendo ser acessados via python, R, SQL e Stata. Eles fornecessem tabelas tratadas de diferentes assuntos de forma gratuita e paga."
  },
  {
    "objectID": "posts/Base dos Dados/Base dos Dados.html#mãos-a-obra",
    "href": "posts/Base dos Dados/Base dos Dados.html#mãos-a-obra",
    "title": "Base dos Dados",
    "section": "Mãos a obra",
    "text": "Mãos a obra\nGoogle Cloud\nTenha uma conta Google logada, acesse seu workspace do Google Cloud e crie um projeto.\n\n\n\n\n\n\n\n\n\n\nCuidado com a quantidade de projetos.\n\n\n\n\n\nComo qualquer serviço da Google existem planos gratuitos e pagos. Atente-se aos limites de números projetos e o tamanho da requisição que você pode fazer mensalmente.\n\n\n\nRStudio\nNo R instale e carregue a biblioteca.\n\n#install.packages(\"basedosdados\")\nlibrary(\"basedosdados\")\n\nForneça o id do seu projeto.\n\nbasedosdados::set_billing_id(\"Id do Projeto\")\n\nSelecionando os dados\nExistem diferentes formas de fazer a requisição dos dados e esta disponível na documentação. A forma favorita é criando uma query, pois posso selecionar uma pequena amostra dos dados. Primeiro vá ao datalake da base dos dados e copie o ID da tabela de interesse.\n\n\n\n\nA query pode ser construida dessa forma (como se fosse uma requisição de dados no SQL).\n\nquery &lt;- \"SELECT *\nFROM basedosdados.br_tse_eleicoes.resultados_candidato_municipio\nWHERE ano = 2022\nAND cargo = \\'presidente\\'\nAND sigla_uf = \\'SP\\'\" # Cuidado com as strings\n# se quiser poder por \"limit 10\" no final para trazer uma pequena amostra \n\n\n\n\n\n\n\nPara quem não tem muita afinidade com SQL\n\n\n\n\n\nSELECT * -&gt; Selecionar todas as colunas da tabela.\nFROM -&gt; Especificar qual a tabela\nWHERE -&gt; Filtros\nAND -&gt; Concatenar todos os filtros\n\n\n\nAgora você pode baixar os dados definindo um diretório e fomato.\n\nbasedosdados::download(query = query,path = \"Diretório\\dados.csv\")\n\nRealize a autenticação\n\n\n\n\n\n\n\n\n\n\nPermissões\n\n\n\n\n\nCertifiquisse de fornecer todas permissões\n\n\n\nAgora você tem os dados disponíveis no seu computador para realizar as análises. Reforço o cuidado com o volume de dados para evitar incovenientes de ter que trocar o email do seu projeto ou ter que esperar sua cota renovar."
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#bibliotecas",
    "href": "posts/Eleição 2022/Eleição 2022.html#bibliotecas",
    "title": "Eleição 2022",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr) #tratamento de dados\nlibrary(tidyr) #tratamento de dados\nlibrary(ggplot2) #gráficos\nlibrary(readr) #leitura de dados\nlibrary(sf) #mapas\nlibrary(geobr) #mapas\nlibrary(knitr) #tabelas \nlibrary(kableExtra) #tabelas \nlibrary(glue)"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#dados",
    "href": "posts/Eleição 2022/Eleição 2022.html#dados",
    "title": "Eleição 2022",
    "section": "Dados",
    "text": "Dados\nO estudo desse post diz respeito das eleições de 2022 com foco no estado de São Paulo. Os dados se tratam de votos válidos, não nulos e não brancos, ou seja, somente o resultado dos partidos. Eles foram obtidos do projeto Base dos Dados, deixo aqui um pequeno tutorial de como utiliza-lo.\n\ndados &lt;- readr::read_csv(\"dados.csv\") \ndados |&gt; head() |&gt; knitr::kable()\n\n\n\nano\nturno\ntipo_eleicao\nsigla_uf\nid_municipio\nid_municipio_tse\ncargo\nnumero_partido\nsigla_partido\nnumero_candidato\nsequencial_candidato\nid_candidato_bd\nresultado\nvotos\n\n\n\n2022\n1\neleicao ordinaria\nSP\n3500105\n61018\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n2\n\n\n2022\n1\neleicao ordinaria\nSP\n3500204\n61034\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n0\n\n\n2022\n1\neleicao ordinaria\nSP\n3500303\n61050\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n4\n\n\n2022\n1\neleicao ordinaria\nSP\n3500402\n61077\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n2\n\n\n2022\n1\neleicao ordinaria\nSP\n3500501\n61093\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n0\n\n\n2022\n1\neleicao ordinaria\nSP\n3500550\n70190\npresidente\n16\nPSTU\n16\n280001607831\n27173\nnao eleito\n0"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#visão-geral",
    "href": "posts/Eleição 2022/Eleição 2022.html#visão-geral",
    "title": "Eleição 2022",
    "section": "Visão Geral",
    "text": "Visão Geral\nQual o número total de votos que os partidos receberam do estado de São Paulo?\nPrimeiro vou agrupar a soma total dos votos por turnos.\n\ndf &lt;- dados |&gt; \n  dplyr::group_by(turno) |&gt; \n  dplyr::summarise(N_votos = sum(votos)) |&gt; \n  dplyr::mutate(turno =case_when(\n     turno == 1 ~\"1°\",\n     turno == 2 ~\"2°\"\n   ))\ndif_perc &lt;-round(((df$N_votos[2] - df$N_votos[1])/df$N_votos[1])*100,2)\n\nAgora posso plotar os dados com ggplot.\n\ndf |&gt; \n  dplyr::mutate(N_votos = N_votos/1000000) |&gt; \n  ggplot2::ggplot(aes(x =turno,y =N_votos,fill =turno,label = round(N_votos,2))) +\n  geom_col(width = 0.5) + \n  scale_fill_manual(values = c(\"#6cb898\",\"#6c9cb8\"),name = \"Turno\") + \n  labs(title = \"Número de votantes por turno no estado de SP\",\n       subtitle = \"eleições de 2022\",\n       x= 'Turno', y= 'Número de votos(em milhões)',\n       legend = \"Turno\"\n       ) +\n  annotate(\"text\",x=1.5,y =18, label = glue::glue('Aumento de\\n{dif_perc}%')) +\n  geom_label(size = 4) +\n\n  theme(plot.title = element_text(face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\n\n\nHouve um aumento de 80 mil votos em relação ao primeiro turno mostrando que ocorreu uma migração possívelmente dos votos nulos e brancos, ou aqueles que não participaram da votação do primeiro dia. Claro nem todos que votaram no votaram no segundo e vice versa.\n\n\n\nComo foi o resultado do primeiro turno?\n\ndados |&gt; \n  dplyr::filter(turno==1) |&gt; \n  dplyr::group_by(sigla_partido) |&gt;\n  dplyr::summarise(votos = sum(votos)) |&gt;\n  dplyr::arrange(desc(votos)) |&gt; \n  knitr::kable(col.names = c(\"Partido\", \"Votos\"),\n               caption = \"Resultado dos Partidos no Primeiro 1°\",\n               align = 'cc')\n\n\nResultado dos Partidos no Primeiro 1°\n\nPartido\nVotos\n\n\n\nPL\n12239989\n\n\nPT\n10490032\n\n\nMDB\n1625596\n\n\nPDT\n898540\n\n\nNOVO\n183719\n\n\nUNIÃO\n153601\n\n\nUP\n21665\n\n\nPTB\n15784\n\n\nPCB\n14943\n\n\nPSTU\n7450\n\n\nDC\n5015\n\n\n\n\n\nQuem venceu em cada município no primeiro turno?\nPosso plotar um mapa utilizando o pacote geobr.\n\nsp_mapa &lt;- geobr::read_municipality(code_muni = 35, year=2018) |&gt; \n  dplyr::rename( id_municipio = code_muni )\n\nUsing year 2018\n\n\nDeterminar os vencedores.\n\nsp_dados_1 &lt;- dados |&gt; \n  dplyr::filter(turno==1) |&gt; \n  dplyr::group_by(id_municipio) |&gt; \n  dplyr::filter(votos == max(votos)) |&gt; \n  dplyr::left_join(sp_mapa,by ='id_municipio')\n\nPlotando os dados.\n\nsp_dados_1 |&gt; \n  ggplot2::ggplot(ggplot2::aes(geometry = geom,fill = sigla_partido),\n                     color= \"black\") +\n  ggplot2::geom_sf() +\n  ggplot2::scale_fill_brewer(palette = \"Set1\",direction = -1,name = \"Partido\") +\n  labs(title = \"Estado de São Paulo\", subtitle = \"Resultado do 1° turno (2022)\") +\n  ggplot2::theme_void()\n\n\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\n\n\nOcorreu um empate no município de Ribeirão do Sul com PT e PL ficaram cada um com 1452 votos.\n\n\n\nQual partido levou mais municípios no primeiro turno?\n\nsp_dados_1 |&gt;\n  dplyr::group_by(sigla_partido) |&gt; \n  dplyr::summarise(Contagem = n()) |&gt; \n  ggplot2::ggplot(aes(x = sigla_partido,y = Contagem)) +\n  ggplot2::geom_col(width = 0.5, fill = c('#295191','#c70c18')) +\n  labs(title = \"Número de Vitórias por Município\", subtitle =  \"eleições de 2022(1°turno)\",\n       y =\"\", x = \"Partidos\") +\n  theme(plot.title = element_text(face = \"bold\"))\n\n\n\n\nComo ficou a região do ABC?\n\nlistaABC = list(3548708, 3547809, 3529401, 3513801, 3548807, 3543303, 3544103)\nsp_dados_1 |&gt; dplyr::filter(id_municipio %in% listaABC) |&gt;  \n  ggplot2::ggplot(ggplot2::aes(geometry = geom,fill = sigla_partido),\n                     color= \"black\") +\n  ggplot2::geom_sf() +\n  ggplot2::scale_fill_brewer(palette = \"Set1\",direction = -1,name =\"Partido\") +\n  labs(title = \"Região do Grande ABC\",\n       subtitle = \"Vencedores do primeiro turno (2022)\") +\n  geom_sf_label(aes(label = name_muni, colors='white')) +\n  ggplot2::theme_void()"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html",
    "href": "posts/Eleição 2022/Eleição 2022.html",
    "title": "Eleição 2022",
    "section": "",
    "text": "As eleições de 2022 foram extremamente concorridas, sendo bem disputadas no primeiro e no segundo turno. Eu quero analisar a quantidade de votos em cada partido, em cada turno e obter outras informações relevantes.\n\n\nFonte: https://agenciabrasil.ebc.com.br/"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#introdução",
    "href": "posts/Eleição 2022/Eleição 2022.html#introdução",
    "title": "Eleição 2022",
    "section": "",
    "text": "As eleições de 2022 foram extremamente concorridas, sendo bem disputadas no primeiro e no segundo turno. Eu quero analisar a quantidade de votos em cada partido, em cada turno e obter outras informações relevantes.\n\n\nFonte: https://agenciabrasil.ebc.com.br/"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#segundo-turno",
    "href": "posts/Eleição 2022/Eleição 2022.html#segundo-turno",
    "title": "Eleição 2022",
    "section": "Segundo Turno",
    "text": "Segundo Turno\nAgora com 2 partidos fica mais fácil comparar resultados. Podemos comparar a diferença de votos entre os partidos em cada turno.\nQual a porcentagem de votos que eles ganharam no segundo turno?\n\ndados |&gt; dplyr::filter(sigla_partido %in% c(\"PL\",\"PT\")) |&gt; \n  dplyr::group_by(turno,sigla_partido) |&gt; \n  dplyr::summarise(soma = sum(votos)) |&gt; \n  tidyr::spread(key = turno,value = soma) |&gt; \n  dplyr::rename(primeiro ='1',segundo = '2') |&gt; \n  dplyr::mutate(dif = round(100*(segundo - primeiro)/primeiro,2)) |&gt; \n  knitr::kable(col.names = c(\"Partido\", \"Primeiro\",\"Segundo\",\"Diferença de Votos (%)\"),\n               caption = \"Resultado dos Partidos nas Eleições de 2022\",\n               align = 'cccc') |&gt; \n  kableExtra::add_header_above(c(\" \" = 1,\"Turno\" = 2, \" \" = 1))\n\n\nResultado dos Partidos nas Eleições de 2022\n\n\n\n\n\n\n\n\n\n\nTurno\n\n\n\n\nPartido\nPrimeiro\nSegundo\nDiferença de Votos (%)\n\n\n\n\nPL\n12239989\n14216587\n16.15\n\n\nPT\n10490032\n11519882\n9.82\n\n\n\n\n\nQuem venceu em cada município no segundo turno?\n\nsp_dados_2 &lt;- dados |&gt; \n  dplyr::filter(turno==2) |&gt; \n  dplyr::group_by(id_municipio) |&gt; \n  dplyr::filter(votos == max(votos)) |&gt; \n  dplyr::left_join(sp_mapa,by ='id_municipio')\n\nsp_dados_2 |&gt; \n  ggplot2::ggplot(ggplot2::aes(geometry = geom,fill = sigla_partido),\n                     color= \"black\") +\n  ggplot2::geom_sf() +\n  ggplot2::scale_fill_brewer(palette = \"Set1\",direction = -1,name =\"Partido\") +\n  labs(title = \"Estado de São Paulo\", subtitle = \"Resultado do 2° turno (2022)\") +\n  ggplot2::theme_void()\n\n\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\n\n\nOcorreu um empate no município de Guará com PT e PL ficaram cada um com 5529 votos.\n\n\n\nQual partido levou mais municípios no segundo turno?\n\nsp_dados_2 |&gt;\n  dplyr::group_by(sigla_partido) |&gt; \n  dplyr::summarise(Contagem = n()) |&gt; \n  ggplot2::ggplot(aes(x = sigla_partido,y = Contagem)) +\n  ggplot2::geom_col(width = 0.5, fill = c('#295191','#c70c18')) +\n  labs(title = \"Número de Vitórias por Município\", subtitle =  \"Eleições de 2022 (2°turno)\",\n       y =\"\", x = \"Partidos\") +\n  theme(plot.title = element_text(face = \"bold\"))\n\n\n\n\nComo ficou a região do ABC no segundo turno?\n\nsp_dados_2 |&gt; dplyr::filter(id_municipio %in% listaABC) |&gt;  \n  ggplot2::ggplot(ggplot2::aes(geometry = geom,fill = sigla_partido),\n                     color= \"black\") +\n  ggplot2::geom_sf() +\n  ggplot2::scale_fill_brewer(palette = \"Set1\",direction = -1,name =\"Partido\") +\n  labs(title = \"Região do Grande ABC\",\n       subtitle = \"Vencedores do segundo turno(2022)\") +\n  geom_sf_label(aes(label = name_muni, colors='white')) +\n  ggplot2::theme_void()"
  },
  {
    "objectID": "posts/Eleição 2022/Eleição 2022.html#conclusão",
    "href": "posts/Eleição 2022/Eleição 2022.html#conclusão",
    "title": "Eleição 2022",
    "section": "Conclusão",
    "text": "Conclusão\nFoi possível tirar muitas informações de um pequeno dataset. O projeto Base dos Dados possui mais tabelas com dados de perfil eleitoral, gastos, votos nulos e brancos., sendo possível realizar análises mais completas."
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html",
    "title": "Arbitragem da Premier League",
    "section": "",
    "text": "A premier League é a liga mais famomasa do mundo, sendo transmitida em vários países, ela é conhecida por ter grandes craques e um jogo frenético.\n\n\nImagem de divulgação da Premier League.\n\nEsse tipo jogo é permitido por conta de uma arbitragem mais permissiva aos contatos físicos entre jogadores, sempre dando preferência pela continuidade da partida realizando pouquissimas intervenções.\nO meu objetivo é analisar a temporada 2021-2022 do ponto de vista da arbitragem levando em consideração cartões , n°jogos e outros parâmetros."
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html#intodução",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html#intodução",
    "title": "Arbitragem da Premier League",
    "section": "",
    "text": "A premier League é a liga mais famomasa do mundo, sendo transmitida em vários países, ela é conhecida por ter grandes craques e um jogo frenético.\n\n\nImagem de divulgação da Premier League.\n\nEsse tipo jogo é permitido por conta de uma arbitragem mais permissiva aos contatos físicos entre jogadores, sempre dando preferência pela continuidade da partida realizando pouquissimas intervenções.\nO meu objetivo é analisar a temporada 2021-2022 do ponto de vista da arbitragem levando em consideração cartões , n°jogos e outros parâmetros."
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html#bibliotecas",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html#bibliotecas",
    "title": "Arbitragem da Premier League",
    "section": "Bibliotecas",
    "text": "Bibliotecas\n\nlibrary(dplyr) #tratamento de dados\nlibrary(ggplot2) #gráficos\nlibrary(readr) #leitura de dados\nlibrary(lubridate) #tratamento de dados \nlibrary(glue)\nlibrary(knitr) #tabelas"
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html#dados",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html#dados",
    "title": "Arbitragem da Premier League",
    "section": "Dados",
    "text": "Dados\nO dataset foi disponibilizado pelo projeto tidytuesday com a autoria de Evan Gower. O projeto disponibiliza diversas bases de dados reais e de forma gratuita.\nOs dados podem ser carregados pela biblioteca:\n\ninstall.packages(\"tidytuesdayR\")\ntuesdata &lt;- tidytuesdayR::tt_load('2023-04-04')\ntuesdata &lt;- tidytuesdayR::tt_load(2023, week = 14)\nsoccer &lt;- tuesdata$soccer\n\nOu pelo link disponibilizado no GitHub.\n\ndados &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-04-04/soccer21-22.csv\")\ndados |&gt; head() |&gt; \n  knitr::kable(caption = \"Tabela\")\n\n\nTabela\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nHomeTeam\nAwayTeam\nFTHG\nFTAG\nFTR\nHTHG\nHTAG\nHTR\nReferee\nHS\nAS\nHST\nAST\nHF\nAF\nHC\nAC\nHY\nAY\nHR\nAR\n\n\n\n13/08/2021\nBrentford\nArsenal\n2\n0\nH\n1\n0\nH\nM Oliver\n8\n22\n3\n4\n12\n8\n2\n5\n0\n0\n0\n0\n\n\n14/08/2021\nMan United\nLeeds\n5\n1\nH\n1\n0\nH\nP Tierney\n16\n10\n8\n3\n11\n9\n5\n4\n1\n2\n0\n0\n\n\n14/08/2021\nBurnley\nBrighton\n1\n2\nA\n1\n0\nH\nD Coote\n14\n14\n3\n8\n10\n7\n7\n6\n2\n1\n0\n0\n\n\n14/08/2021\nChelsea\nCrystal Palace\n3\n0\nH\n2\n0\nH\nJ Moss\n13\n4\n6\n1\n15\n11\n5\n2\n0\n0\n0\n0\n\n\n14/08/2021\nEverton\nSouthampton\n3\n1\nH\n0\n1\nA\nA Madley\n14\n6\n6\n3\n13\n15\n6\n8\n2\n0\n0\n0\n\n\n14/08/2021\nLeicester\nWolves\n1\n0\nH\n1\n0\nH\nC Pawson\n9\n17\n5\n3\n6\n10\n5\n4\n1\n2\n0\n0"
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html#mão-na-massa",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html#mão-na-massa",
    "title": "Arbitragem da Premier League",
    "section": "Mão na massa",
    "text": "Mão na massa\nQuem apitou mais jogos?\n\ndados |&gt; \n  dplyr::group_by(Referee) |&gt; \n  dplyr::summarise(nJogos = n(),\n                   faltas = sum(HF) + sum(AF),\n                   amarelos = sum(HY) + sum(AY),\n                 vermelhos =sum(HR) + sum(AR) ) |&gt; \n  dplyr::arrange(desc(nJogos)) |&gt; \n  dplyr::slice(1:10) |&gt; \n  knitr::kable(caption = \"Temporada 2021-2022\",\n               col.names = c(\"Árbitros\",\"N°Jogos\",\"N°Faltas\",\n                        \"Amarelos\",\"Vermelhos\"),\n               align = \"ccccc\")\n\n\nTemporada 2021-2022\n\nÁrbitros\nN°Jogos\nN°Faltas\nAmarelos\nVermelhos\n\n\n\nA Taylor\n28\n548\n101\n5\n\n\nP Tierney\n27\n583\n103\n5\n\n\nC Pawson\n26\n576\n107\n2\n\n\nM Atkinson\n26\n406\n64\n2\n\n\nM Dean\n26\n501\n82\n2\n\n\nM Oliver\n26\n551\n73\n7\n\n\nJ Moss\n25\n448\n58\n4\n\n\nD Coote\n20\n476\n90\n2\n\n\nS Attwell\n20\n364\n70\n1\n\n\nA Marriner\n19\n365\n61\n2\n\n\n\n\n\nEm que mês saiu mais cartão amarelo?\n\ndf_Jogos_cartao &lt;-  dados |&gt; \n  dplyr::mutate(mes = lubridate::month(Date,label = TRUE)) |&gt; \n  dplyr::group_by(mes) |&gt; \n  dplyr::summarise(jogos = n(),\n                   cartao = sum(HY) + sum(AY) + sum(HR) + sum(AR)) \n\ndf_Jogos_cartao |&gt; ggplot2::ggplot(aes(x= mes, y =cartao, label = cartao)) +\n  ggplot2::geom_col(fill = \"#1b662c\" ) +\n  ggplot2::geom_label() +\n  labs(title = \"Distribuição de Cartões na Premier League\",\n       subtitle = \"Amarelos e vermelhos da temporada 2021-2022\",\n       x = \"Mês\", y = \"N°de Cartões\",\n       caption = \"Mendes, Jorge L.\") +\n  ggplot2::geom_hline(yintercept=mean(df_Jogos_cartao$cartao),linetype = 2) +\n  ggplot2::annotate(\"text\",x = 6,y =145, \n                    label = glue::glue(\"Média:{mean(df_Jogos_cartao$cartao)}\")) +\n  theme(plot.title = element_text(face = \"bold\",size = 14),\n         axis.text.y =element_text(face =\"bold\",\n                                    colour = \"#030202\"),\n         axis.text.x =element_text(face =\"bold\",\n                                    colour = \"#030202\"))\n\n\n\n\n\n\n\n\n\n\nCuriosidade!!!\n\n\n\n\n\nAs competições Europeias seguem, em geral, o calendário é internacional. A temporada começa em agosto de determinado ano e termina em maio do ano seguinte. A premier league tem uma particularidade (se comparada com as outras grandes ligas) no seu calendário, o intervalo entre os jogos de dezembro é menor, tendo a rodada do Boxing Day com partidas ocorrendo dia 26 de dezembro.\n\n\n\nO quanto o número de jogos impactam na quantidade de cartões?\n\ndf_Jogos_cartao |&gt; ggplot(aes(x = mes, y=jogos)) +\n  ggplot2::geom_point(aes(size = cartao),color= \"#424d6b\") +\n  labs(title = \"Distribuição de Jogos da Premier League\",\n       subtitle = \"Temporada 2021-2022\",\n       x = \"Mês\", y = \"N°de Jogos\",\n       caption = \"Mendes, Jorge L.,2024\") +  \n theme(plot.title = element_text(face = \"bold\",size = 14),\n         axis.text.y =element_text(face =\"bold\",\n                                    colour = \"#030202\"),\n         axis.text.x =element_text(face =\"bold\",\n                                    colour = \"#030202\"))\n\n\n\n\n\n\n\n\n\n\nCartões Amarelos\n\n\n\n\n\nDiferente do campeonato brasileiro é necessário 5 cartões para o jogador ser suspenso na Premier League.\n\n\n\nConsiderando os árbitros que mais distribuiram cartões amarelos nessa temporada (2021-2022). Quais os clubes preferidos deles?\nSelecionando os árbitros e separando os times.\n\nlista_arbitro &lt;- c(\"C Pawson\",\"P Tierney\",\"A Taylor\",\"D Coote\")\na_H &lt;- dados |&gt; dplyr::filter(Referee %in% lista_arbitro) |&gt; \n  dplyr::group_by(Referee,HomeTeam) |&gt; \n  dplyr::summarise(cartaoH = sum(HY)) |&gt;\n  dplyr::rename(time = HomeTeam)\na_A &lt;- dados |&gt; dplyr::filter(Referee %in% lista_arbitro) |&gt; \n  dplyr::group_by(Referee,AwayTeam) |&gt; \n  dplyr::summarise(cartaoA = sum(AY)) |&gt;\n  dplyr::rename(time = AwayTeam)\n\ndf &lt;-a_H |&gt; dplyr::full_join(a_A) |&gt; \n  dplyr::mutate(cartao = coalesce(cartaoH,0) + coalesce(cartaoA,0)) |&gt; \n  dplyr::select(1,2,5) |&gt; \n  dplyr::group_by(Referee) |&gt; \n  dplyr::top_n(5,cartao)\n\n \nto_add &lt;- data.frame( matrix(NA, 0,ncol(df)) )\ncolnames(to_add) &lt;- colnames(df)\nto_add$Referee &lt;- rep(levels(df$Referee), each = 0)\nto_add$time &lt;- as.factor(to_add$time)\n\ndf &lt;- rbind(df, to_add)\ndf &lt;- df %&gt;% arrange(Referee)\ndf$id &lt;- seq(1, nrow(df))\n\nConstruindo os arcos e definindo os limites.\n\nlabel_data &lt;- df\nnumber_of_bar &lt;- nrow(label_data)\nangle &lt;- 90 - 360 * (label_data$id-0.5) /number_of_bar     \nlabel_data$hjust &lt;- ifelse(angle &lt; -90, 1, 0)\nlabel_data$angle &lt;- ifelse(angle &lt; -90, angle+180, angle)\nbase_data &lt;- df |&gt; \n  group_by(Referee) |&gt;  \n  summarize(start=min(id), end=max(id) ) |&gt; \n  rowwise() |&gt; \n  mutate(title=mean(c(start, end)))\n\ngrid_data &lt;- base_data\ngrid_data$end &lt;- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1\ngrid_data$start &lt;- grid_data$start - 1\ngrid_data &lt;- grid_data[-1,]\n\nFinalmente podemos construir o gráfico.\n\nggplot(df, aes(x=as.factor(id), y=cartao, fill=Referee)) +      \n  \n  geom_bar(aes(x=as.factor(id), y=cartao, fill=Referee), \n           stat=\"identity\", alpha=0.5) +\n  \n  \n  geom_bar(aes(x=as.factor(id), y=cartao, fill=Referee)\n           , stat=\"identity\", alpha=0.5) +\n  ylim(-100,120) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(rep(-1,4), \"cm\") \n  ) +\n  coord_polar() + \n  geom_text(data=label_data, aes(x=id, y=cartao+10, label=time, hjust=hjust), \n            color=\"black\", fontface=\"bold\",alpha=0.6, \n            size=2.5, angle= label_data$angle, inherit.aes = FALSE ) +\n  \n  geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5),\n               colour = \"black\", alpha=0.8, linewidth=0.6 , inherit.aes = FALSE )  +\n  geom_text(data=base_data, aes(x = title, y = -15, label=Referee),\n            hjust=c(0.95,0.95,0.1,0.1), colour = \"black\", alpha=0.8, size=3, \n            fontface=\"bold\", inherit.aes = FALSE)"
  },
  {
    "objectID": "posts/Arbitragem da PL/Arbitragem_PL.html#conclusão",
    "href": "posts/Arbitragem da PL/Arbitragem_PL.html#conclusão",
    "title": "Arbitragem da Premier League",
    "section": "Conclusão",
    "text": "Conclusão\nO tidytuesday é uma excelente uma excelente biblioteca, pois fornece bastante bases de dados para praticar permitindo diversos tipos de análises."
  }
]